
%\IEEEtitleabstractindextext{
\begin{abstract}
  Causal broadcast constitutes a fundamental communication primitive of many
  distributed protocols and applications. However, state-of-the-art
  implementations fail to forget obsolete control information about already
  delivered messages. They do not scale in large and dynamic systems.  In this
  paper, we propose a novel implementation of causal broadcast.  We prove that
  all and only obsolete control information is safely removed, at cost of a few
  lightweight control messages. The local space complexity of this protocol does
  not monotonically increase and depends at each moment on the number of
  messages still in transit and the degree of the communication graph. Moreover,
  messages only carry a scalar clock.  Our implementation constitutes a
  sustainable communication primitive for causal broadcast in large and dynamic
  systems.
\end{abstract}
%}

% \begin{abstract}
%   Causal broadcast constitutes the core communication primitive of many
%   distributed systems. For decades, state-of-the-art approaches relied on
%   maintaining and transmitting vector clocks. The size of vector clocks
%   increases linearly with the number of processes that ever entered the
%   system. Causal broadcast eventually became overcostly and inefficient in large
%   and dynamic systems.  A recent approach solved the issue about generated
%   traffic by removing the need for transmitting vectors. However, it still
%   maintains a vector locally. In this paper, we improve this causal broadcast by
%   removing the need for such vector. The proposed protocol safely purges the
%   local structure over time at cost of few control messages. As consequence,
%   causal broadcast can run in large and dynamic systems even on most humble
%   devices such as Raspberry Pi's.
% \end{abstract}

% \keywords{Causal broadcast, local space complexity}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
