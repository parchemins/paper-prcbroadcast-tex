 
\section{Introduction}

%\IEEEPARstart{C}{ausal}

Causal broadcast constitutes the core communication primitive of many
distributed systems~\cite{hadzilacos1994modular}. Applications such as
distributed social networks~\cite{borthakur2013petabyte}, distributed
collaborative software~\cite{heinrich2012exploiting,nedelec2016crate}, or
distributed data
stores~\cite{bailis2013bolton,bravo2017saturn,demers1987epidemic,lloyd2011cops,shapiro2011comprehensive}
use causal broadcast to ensure consistency criteria.  Causal broadcast ensures
reliable receipt of broadcast messages, exactly-once delivery, and causal
delivery following Lamport's happen before
relationship~\cite{lamport1978time}. When Alice comments on Bob's picture,
nobody sees Alice's comment without Bob's picture, and nobody sees multiple
occurrences of Alice's comment or Bob's picture.
% If the sending of a message $m$ precedes the sending of a message $m'$ then all
% processes that deliver these two messages need to deliver $m$ before
% $m'$. Otherwise they deliver them in any order.

However, causal broadcast implementations do not scale in large and dynamic
systems comprising from hundreds to millions of processes joining, leaving, and
self-reconfiguring at any time. While ensuring causal delivery can be
lightweight~\cite{nedelec2018pcbroadcast}, forbidding multiple delivery is
either restrictive in terms of system topology, or overly space consuming. Every
process delivers every message exactly-once by either
\begin{inparaenum}[(i)]
\item building a specific dissemination topology such as a tree or a ring that
  ensures single receipt hence single
  delivery~\cite{bravo2017saturn,raynal2013distributed}. However, such
  topologies are difficult to maintain in dynamic systems subject to
  failures~\cite{krasikova2016hashtable};
\item or they maintain a local structure to identify and discard additional
  copies of an original message at receipt. In asynchronous systems, these
  structures use logical clocks~\cite{malkhi2007concise,mukund2014optimized}.
  However, such structures suffer from linearly and monotonically increasing
  size with the number of processes that ever broadcast a message.  These
  approaches eventually become inefficient, for processes cannot safely reclaim
  consumed space without running an overcostly distributed garbage collecting
  protocol~\cite{abdullahi1998garbage}. State-of-the-art causal broadcast
  implementations do not scale in large and dynamic systems.
\end{inparaenum}

In this paper, we introduce an implementation of causal broadcast that belongs
to approaches forbidding multiple delivery by using local structures and
logical clocks.
% A process belongs to an overlay network and has neighbors to communicate with
% via incoming and outgoing links.  Broadcast efficiently disseminates messages by
% gossiping~\cite{jelasity2007gossip}: the broadcaster sends the message by its
% outgoing links; each process receiving such message forwards it by its own
% outgoing links. Processes receive the message either directly or
%transitively. 
Our contribution is threefold:
\begin{itemize}[leftmargin=*]
\item We define link memory as a mean for each process to forbid multiple
  delivery. A process may receive a message multiple times from different
  processes. Despite multiple receipts, a process must deliver a message exactly
  once.  Link memory allows each process to identify processes from which it
  will receive a copy of an already delivered message. This allows each process
  to safely remove obsolete control information about broadcast messages that
  will never be received again. Assuming causal order, we prove that each
  process can build such knowledge even in dynamic systems where processes join,
  leave, or self-reconfigure at any time.
\item We analyze the complexity of our implementation of link memory for causal
  broadcast. Our implementation offers a novel trade-off between speed, memory,
  and traffic that actually depends on system settings and current use: the
  number of communication links, and the number of broadcast messages currently
  spreading in the system (the spreading time being upper bounded by the
  diameter of the system). Quiescent systems where no process broadcasts any
  message enjoy no overhead. Our implementation does not assume any specific
  topology. However, to implement link memory in dynamic systems, we require
  lightweight control messages the number of which depends on routing
  capabilities of the system and its dynamicity.  For instance, gossip-based
  peer-sampling
  protocols~\cite{jelasity2007gossip,jelasity2009tman,nedelec2017adaptive} need
  only 8 control messages per added link.
\item We evaluate our implementation using large scale simulations. The
  experiments highlight the space consumed and the traffic generated by our
  protocol in dynamic systems with varying latency. The results confirm that the
  proposed approach scales with system settings and use.
\end{itemize}
Every process maintains a local state registering receipts from processes that
actually send it messages instead of maintaining a global state registering
receipts from all processes of the system in a vector of logical clocks. The
former set of processes being far smaller than the set of processes in the
system, our approach scales in large and dynamic systems.  Our implementation
offers an advantageous trade-off that makes causal broadcast a lightweight and
efficient middleware in large and dynamic systems.

The rest of this paper is organized as follows.
% Section~\ref{sec:motivations}
% shows the issue and motivates this work.
Section~\ref{sec:proposal} describes the model, highlights the issue, introduces
the principle solving the issue, provides an implementation solving the issue
along with its complexity analysis. Section~\ref{sec:experimentation} shows the
experiments. Section~\ref{sec:relatedwork} reviews related work. We conclude in
Section~\ref{sec:conclusion}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
