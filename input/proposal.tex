
\section{Proposal}
\label{sec:proposal}

In this section, we present \RPCBROADCAST, a causal broadcast protocol removing
the last linear upper bound in terms of number of processes that ever broadcast
a message that remained on space complexity. \RPCBROADCAST exploits the
improvement brought by \PCBROADCAST on generated traffic to reduce the space
consumed by reliable broadcast, at marginal cost.

\subsection{Model}

A distributed system comprises a set of processes that can communicate with each
other using messages. Processes may not have full knowledge of the membership of
the system. Instead, processes build and maintain overlay networks: each process
updates a local partial view of logical communication channels, i.e., a set of
processes to communicate with. The partial view is usually much smaller than the
actual system size. We speak of overlay networks, networks, or distributed
systems indifferently.

\begin{definition}[Overlay network]
  An overlay network comprises a set of processes that run a set of instructions
  sequentially.  An overlay network also comprises a set of directed
  links. \\
  An overlay network is dynamic if the set of processes or the set of links is
  mutable. Otherwise, the overlay network is static. \\
  The set of links departing from a process is its neighborhood, or partial
  view, or out-view. The set of links arriving to a process is its in-view. \\
  A link from a process to another process allows the former to transmit
  information to the latter. Processes transmit information using asynchronous
  message passing.\\
  Processes are faulty if they crash, otherwise they are correct. There are no
  byzantine processes.
\end{definition}

Processes can communicate with each other using message passing. Process~A can
send a message $m$ to Process~B $s_{AB}(m)$. Process~A can receive a message $m$
from another process B $r_{AB}(m)$, or from any other process
$r_A(m)$. Process~A can send a message $m$ to all other processes of the system,
i.e., it broadcasts a message $b_A(m)$. Process~A can deliver a message
$d_A(m)$.


\begin{definition}[Uniform reliable broadcast] 
  When a process broadcasts a message to all processes of the network, correct
  processes eventually receive it. Uniform reliable broadcast guarantees 3
  properties:
  \begin{itemize}
  \item Validity: If a correct process broadcasts a message, then it
    eventually delivers it.
  \item Uniform Agreement: If a process -- correct or not -- delivers a message,
    then all correct processes eventually deliver it.
  \item Uniform Integrity: A process delivers a message at most once, and only if
    it was previously broadcast.
  \end{itemize}
\end{definition}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast that purges its local structure over time but only in static
networks. The implementation uses the in-view and exploits the property that
each process sends each message exactly once to each neighbor in their
out-view. It associates with each link from the in-view a set of awaited
messages. When Process~A receives a message for the first time from Process~B,
it awaits a copy of this message from all other processes in its in-view. When
it receives such copy, it removes the message from the set of awaited messages
of the corresponding link. Process~A will never receive a copy of this message
from this link. Once it received all awaited copies, it will never receive a
copy of this message. The principle of this implementation is similar to that of
Figure~\ref{fig:generalpurge} to which it adds an awareness of links with
awaited messages. Using this reliable broadcast implementation, each process
delivers each message exactly once.

In addition to reliable delivery, broadcast protocols can guarantee a delivery
order of messages. To define a delivery order among messages, we define time in
a logical sense using Lamportâ€™s definition. 

\begin{definition}[Happen before~\cite{lamport1978time}]
  Happen before is a transitive, irreflexive, and antisymmetric relation that
  defines a strict partial orders of events. The sending of a message always
  precedes its receipt.
\end{definition}

Causal order enforces a delivery order among messages. It states that Process~A
should deliver a message $m$ from Process~B after having delivered all messages
delivered by Process~B before the sending of $m$.

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts.
\end{definition}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

\PCBROADCAST (\REF) is a causal broadcast that uses \TODO{reliable ?} FIFO
links, control messages, and buffers to ensure causal order in dynamic
systems. A process broadcasting a message sends the message to an out-view of
safe links.

\begin{definition}[\label{def:safe}Safe link] 
  A link from Process A to Process B is safe if and only if Process B received
  or will receive all messages delivered by Process A before receiving any
  message that Process A will
  deliver: $safe(AB) \equiv \forall m,\, m',\, d_A(m) \rightarrow s_{AB}(m')
  \implies r_B(m) \rightarrow r_{AB}(m')$
\end{definition}

Links start unsafe. \PCBROADCAST ensures that they are safe, i.e., they cannot
cause causal order violations, by sending control messages.

\begin{definition}[Ping phase]
  Ping phase starts when Process~A pings Process~B. Ping messages $\pi$ travel
  using safe links. When Process~B receives this ping, it replies to
  Process~A. Replies $\rho$ travel using any communication mean. Ping phase ends
  when Process~A receives the reply of Process~B.
\end{definition}

\begin{lemma}[\label{lemma:ping}Ping phases acknowledge broadcast receipts]
  A ping phase from Process~A to Process~B acknowledges the receipt by B of all
  messages delivered by Process~A before this ping phase:
  $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge r_A(\rho_{AB}) \implies
  r_B(m)$
\end{lemma}

In this paper, we extend the meaning of safe link to not only ensure causal
order but also exactly once delivery. This is more expensive to ensure, for it
must account for concurrent messages. \TODO{More}

%broadcast requires more ping phases and
%more buffers.


\subsection{Operation}

Algorithm~\ref{algo:rpcbroadcast} shows the instructions of the proposed causal
broadcast. It relies on an implementation of reliable broadcast shown in
Algorithm~\ref{algo:reliablebroadcast}. When the process does not add links to
other processes, nor other processes add links to this process, causal broadcast
operation is that of reliable broadcast.

When the process wants to add a link to another process for causal broadcast, it
makes sure that this link cannot break the guaranty that the other process
delivers each message exactly once in causal order.


\begin{definition}[Safe link extension]
  In addition to Definition~\ref{def:safe}, a link from Process~A to Process~B
  is safe if Process~B does not deliver the messages received via this new link
  if it already delivered this message, and delivers it otherwise.
\end{definition}

This extension of the original definition implies that Process~B is able to
distinguish messages it already delivered that are not received by Process~A
from messages it receives for the first time by Process~A.

\begin{algorithm}[h]
  \input{./input/algorpcbroadcast.tex}
  \caption{\label{algo:rpcbroadcast}RPC-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:rpcbroadcast} shows the instructions of the proposed
reliable causal broadcast. Similarly to \PCBROADCAST, it follows the behavior of
reliable broadcast when the out-view does not change. 

Figure~\ref{fig:timeline} depicts the functioning of \RPCBROADCAST when
Process~A adds Process~B in its out-view, it removes it from links used for
causal broadcast. Process~A sends a first control message $\alpha$ to Process~B
using safe links. Process~B receives $\alpha$ after all messages $\mathcal{A}$
delivered by Process~A before the sending of $\alpha$ plus other concurrent
messages $\mathcal{B}$. Process~B sends a second control message using safe
links to Process~A. Process~B starts to register messages it delivers in a
buffer $B_\alpha$.  Once Process~A receives $\beta$, it received $\mathcal{B}$
plus other concurrent messages $\mathcal{C}$. Process~A starts to register
messages it delivers in a buffer $B$. $B_\alpha$ and $B$ do not contain messages
from $\mathcal{A}$ and $\mathcal{B}$. Then, Process~A sends a third control
message $\pi$ to Process~B using safe link. This corresponds to the ping phase
of \PCBROADCAST.  Once Process~B receives $\pi$, it delivered and buffered all
messages in $\mathcal{C}$ plus concurrent messages $\mathcal{D}$. $B_\alpha$
contains all concurrent messages between $s_B(\beta_{BA})$ and
$r_B(\pi_{AB})$. Most importantly, it contains the concurrent messages between
$s_A(\pi_{AB})$ and $r_B(\pi_{AB})$. It also contains meaningless messages from
$\mathcal{C}$.  Process~B stops to buffer messages in $B_\alpha$ and starts to
register messages it delivers in $B_\pi$. It sends a fourth and last control
message $\rho$ to Process~B using safe links. Once Process~A receives $\rho$, it
delivered all concurrent messages $\mathcal{D}$ plus other concurrent messages
$\mathcal{E}$. Process~A sends its buffer of messages $B$ using the new link
$s_{AB}(B)$ and starts using this link normally. The new link is safe. When
Process~B receives the buffer, it identifies the messages it never received
$B\setminus B_\alpha \setminus B_\pi$ and delivers them in causal order. Also,
when Process~B receives the buffer, it identifies the messages it already
received but not delivered by Process~A, hence, that it will eventually receive
again via the new link: $B_\pi \setminus (B \setminus B_\alpha)$.  It registers
these messages to discard them when they arrive.

\begin{figure*}
  \begin{center}
    \input{input/figtimelinerpcbroadcast.tex}
    \caption{\label{fig:timeline}Timeline of \RPCBROADCAST when Process~A adds a
      link to Process~B in its out-view. We hide intermediate processes for the
      purpose of clarity.}
  \end{center}
\end{figure*}

Similarly to \PCBROADCAST, the size of buffer may increases without limit when
intermediate processes are faulty. Control messages never reach their
destination. \PCBROADCAST handles such crashes using a timeout and retry
policy. Such strategy fits \RPCBROADCAST.


\subsection{Complexity}
\label{subsec:complexity}

In this section, we analyze the complexity of \RPCBROADCAST in terms of
broadcast message overhead, delivery execution time, local space consumption,
and number of control messages. 

\noindent The \textbf{broadcast message overhead} is constant $O(1)$, for it
only piggyback the control information to ensure reliable FIFO links.

\noindent The \textbf{delivery execution time}, i.e., the time complexity of the
receipt function, is constant $O(1)$, for it only checks if the message should
be discarded or delivered.

\noindent The \textbf{local space consumption} depends on the size of
buffers. There are 4 buffers in total. $W$ is the size of buffers related to
reliable FIFO links. A link may delay the delivery of messages to await some
preceding messages. $B$ is the size of buffers of messages that increases when
the process adds a neighbor in its out-view, and decreases when a link become
safe. $B_\alpha$ and $B_\pi$ are the size of buffers of messages that increases
when the process gets added as neighbor, and decreases when a links in its
in-view become safe. The space complexity of \RPCBROADCAST is
$O(W + B + B_\alpha + B_\pi)$. It grows and shrinks depending on the dynamicity
of the system. If the system becomes static, the space complexity of
\RPCBROADCAST is $O(W)$. If the system becomes quiescent, the space complexity
of \RPCBROADCAST is $O(B + B_\alpha + B_\pi)$.  If the system becomes both
static and quiescent, \RPCBROADCAST does not consume
space. 

\noindent The overhead in terms of \textbf{number of control messages} per added
link in an out-view varies from $6$ to $4N^2$ depending on the overlay
network. It achieves $6$ messages when Process~A adds Process~B using Process~C
as mediator, and Process~B has Process~A in its out-view. It achieves $4N^2$
when Process~A adds Process~B without knowledge of any route. Process~A and
Process~B fall back to reliable broadcast to disseminate control
messages. \TODO{$N$ is the size of the network.}

Overall, this analysis shows that \RPCBROADCAST proposes an advantageous
tradeoff when the overlay network allows routing between the process that adds
the neighbor and the latter. Fortunately, a wide range of peer-sampling
protocols building overlay networks rely on close neighbor-to-neighbor
interactions to establish links (\REF). An \RPCBROADCAST built on top of these
peer-sampling protocols achieves $8$ control messages per added link. Several
other peer-sampling protocols build addressable overlay networks which allows
routing with a logarithmic number of hops compared to the actual network size
(\REF). An \RPCBROADCAST built on top of these peer-sampling protocols achieves
$O(4\log(N))$ control messages per added link.

Assuming such overlay network, \RPCBROADCAST constitutes a lightweight and
efficient middleware for reliable broadcast and causal broadcast in large and
dynamic distributed systems. As consequence, these broadcast can run in large
and dynamic systems even on most humble devices such as Raspberry Pi's.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
