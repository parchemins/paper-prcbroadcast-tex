 
\section{Introduction}

Causal broadcast (\REF) constitutes the core communication primitive of many
distributed systems (\REF). It ensures the reliable delivery of broadcast
messages, exactly once, following Lamport's happen before
relationship~\cite{lamport1978time}. If the sending of a message $m$ precedes
the sending of a message $m'$ then all processes that deliver these two messages
need to deliver $m$ before $m'$. Otherwise they deliver them in any order.

In large and dynamic systems, processes cannot afford to maintain an up-to-date
knowledge of the full membership (\REF). Instead, each process builds a partial view of
neighbors to communicate with. Gossiping (\REF) exploits these neighborhoods to
efficiently broadcast a message to all processes. To broadcast a message, a
process sends the message to its neighbors; each process receiving such message
forwards it to its own neighbors. Processes receive the message either directly
or transitively. Processes may receive a broadcast message multiples times from
different sources.  To deliver each message exactly once, reliable broadcast
must discard the additional copies of the original message at receipt.

In static systems where processes cannot join, leave, or self-reconfigure their
neighborhood, the local structure that ensures exactly once delivery is
lightweight.  Since each process forwards each message exactly once, each
process knows that it will receive a number of copies of the original message
equal to the number of their incoming links. Once it received that many copies,
it safely purges its local structure from this message. It will never receive
this message again.  However, in dynamic systems, when a process adds a neighbor
to its partial view, the latter does not know if it should expect another
message copy from this new incoming link. It may cause multiple deliveries of a
same message.

To solve this, broadcast protocols maintain a summary of past delivered messages
(\REF). Upon receipt, processes quickly identify whether they should deliver the
message or discard it. However, the size of this structure increases linearly
with the number of processes that ever broadcast a message (\REF). This dampens
the usage of broadcast protocols. In particular, humble devices with limited
local memory cannot afford it, and reclaiming elements from the structure
requires an overcostly distributed consensus (\REF).

% \TODO{We do reliable broadcast on top of causal broadcast. Did not make sense
%   before because the cost of causal broadcast was too high. Now that it's cheap,
%   we use it to enable reliability at marginal cost.}

% State-of-the-art causal broadcasts (\REF) reuse this vector of clocks. Each
% message piggybacks such vector to ensure their causal delivery. A recent causal
% broadcast (\REF) alleviates processes from the need for piggybacking vectors in
% messages. However, it still requires to maintain the local vector to ensure that
% it delivers each message exactly once.

\begin{table*}
  \begin{center}
    \caption{\label{table:complexity} Complexity of causal broadcast algorithms
      at each process. $N$ the number of processes that ever broadcast a
      message. $P$ the number of processes in the system. $W$ the number of 
      messages received but not delivered yet. $B$ and $D$ are buffers of
      messages that increase when a link is added but purged when the link
      becomes safe to use. $B$ and $D$ eventually becomes empty when the system
      becomes static.}
    \input{input/tablecomplexity.tex}
  \end{center}
\end{table*}

In this paper, we present a causal broadcast protocol that exploits causal order
to get rid of the summary of past delivered messages. 
%\TODO{Maybe more generic: on top of any causal broadcast? Along with
%  \PCBROADCAST it removes the last linear complexity?}
Our contribution is threefold:
\begin{itemize}[leftmargin=*]
\item We extend the causal broadcast protocol proposed in (\REF) to remove the
  last linear upper bound in terms of number of processes that ever broadcast a
  message that remains on local space complexity. Similarly to \REF, it only
  makes use of temporary buffers and few control messages to ensure both causal
  order and reliability. We provide the corresponding formal proof.
  % describe a causal broadcast that piggybacks constant size control information
  % while maintaining a local structure that is safely purged over time, and we
  % prove it.
\item We provide the complexity analysis of our causal broadcast
  protocol. Table~\ref{table:complexity} shows that removing the last linear
  upper bound $N$ cost twice as much in terms of number of control messages as
  ensuring causal order. Depending on the system (\REF), the number of messages
  stays close to its lower bound $6$. The local space consumption consists of
  buffers that grow and shrink in dynamic settings.
\item We provide experimentation highlighting the impact of our protocol on
  transmission delays before delivery and the generated traffic. \TODO{More.}
\end{itemize}
\RPCBROADCAST proposes an advantageous tradeoff that makes causal broadcast a
lightweight and efficient middleware in large and dynamic systems. This tradeoff
even makes \RPCBROADCAST a lightweight and efficient implementation of reliable
broadcast. By removing the last linearly and monotonically increasing structure,
these broadcast protocols can run in large and dynamic systems even on most
humble devices such as Raspberry Pi's. \TODO{It also makes scalable all
  protocols that rely on causal broadcast.}

The rest of this paper is organized as follows. Section~\ref{sec:motivations}
shows the issue and motivates this work. Section~\ref{sec:proposal} presents the
proposed causal broadcast and corresponding
proofs. Section~\ref{sec:experimentation} highlights the pros and cons of our
approach on experimental setups. We conclude in Section~\ref{sec:conclusion}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
