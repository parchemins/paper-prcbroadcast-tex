
\section{Proposal}
\label{sec:proposal}

In this section, we present a causal broadcast protocol providing an original
tradeoff in terms of complexity. It removes the last linear and monotonic upper
bound that remained on space complexity at the cost of few lightweight control
messages. The key ideas are:
\begin{enumerate}
\item Each process broadcasts or forwards a message once, hence each link convey
  a message once. After the first receipt, the process expects to receive
  another copy of this message from each other link pointing to it. Once the
  process received all copies, the control information associated to the message
  is entirely and safely removed.
\item Adding links between processes adds uncertainty. Processes cannot tell if
  they should expect a message from a link any longer.
\item By exploiting causal order, processes remove this uncertainty. Causal
  order allows to remove batches of obsolete information while reasoning about
  temporarily buffered broadcast messages. In this paper, we exploit causal
  broadcast to improve its underlying reliable broadcast.
\end{enumerate}

\subsection{Model}

A distributed system comprises a set of processes that can communicate with each
other using messages. Processes may not have full knowledge of the membership of
the system. Instead, processes build and maintain overlay networks: each process
updates a local partial view of logical communication links, i.e., a set of
processes to communicate with. The partial view is usually much smaller than the
actual system size. We speak of overlay networks, networks, or distributed
systems indifferently.

\begin{definition}[Overlay network]
  An overlay network $G: P \times E$ comprises a set of processes $P$ and a set
  of directed links $E: P \times P$.  An overlay network is static if both sets
  $P$ and $G$ are immutable. Otherwise, the overlay network is dynamic. An
  overlay network is unpartitioned if their exists a path -- i.e. a link or an
  array of links -- from any process to any other process. We only consider
  unpartitioned overlay networks.
\end{definition}

\begin{definition}[Process]
  A process runs a set of instructions sequentially. Processes communicate with
  each other using asynchronous message passing. A process~A can send a message
  to another process~B $s_{AB}(m)$, or to any process $s_A(m)$; receive a
  message from another process~B $r_{AB}(m)$, or from any process $r_A(m)$. A
  process sends messages to the set of links departing from it, called
  neighborhood, or partial view, or out-view $Q_o$. A process receives messages
  from the set of links arriving to it, called in-view $Q_i$.  Processes are
  faulty if they crash, otherwise they are correct. We do not consider byzantine
  processes.
\end{definition}

Causal broadcast relies on reliable broadcast that provides guarantees on
message delivery. Each process receives each broadcast message at least once and
delivers it once despite possible multiple receipts.

\begin{definition}[\label{def:reliablebroadcast}Uniform reliable broadcast] 
  When a process~A broadcasts a message to all processes of its system $b_A(m)$,
  each correct process~B eventually receives it and delivers it
  $d_B(m)$. Uniform reliable broadcast guarantees 3 properties:
  \begin{itemize}[leftmargin=*]
  \item Validity: If a correct process broadcasts a message, then it
    eventually delivers it.
  \item Uniform Agreement: If a process -- correct or not -- delivers a message,
    then all correct processes eventually deliver it.
  \item Uniform Integrity: A process delivers a message at most once, and only if
    it was previously broadcast.
  \end{itemize}
\end{definition}

Definition~\ref{def:reliablebroadcast} suggests the use of data structures that
saves delivered messages to ignore additional receipts. In static systems, such
data structure can be non-monotonic~\cite{raynal2013distributed}. We define a
non-monotonic link-wise memory to forbid multiple delivery.

\begin{definition}[\label{def:memory}Link memory]
  A link from Process~A to Process~B remembers among Process~B's delivered
  messages those that will be received from Process~A; and forgets among
  Process~B's delivered messages those that will never be received from
  Process~A.\\
  $\forall m,\, remember_{BA}(m) \equiv d_B(m) \wedge \neg r_{BA}(m)$ \\
  $\forall m,\, remember_{BA}(m) \implies r_{BA}(m)$
\end{definition}


\begin{theorem}[Link memory forbids multiple delivery]
  Assuming that each link conveys each message at most once, link memory is
  sufficient to forbid multiple delivery.
\end{theorem}

\begin{proof}
  We must show that
  $\not\exists m, d_B(m) \rightarrow r_{BA}(m) \wedge r_{BA}(m) \rightarrow
  d_B(m)$.
  The delivery $d_B(m)$ implies a prior receipt $r_B(m)$.  To deliver $m$ after
  its receipt from Process~A, Process~B must not remember $m$ on this link.  If
  Process~B does not remember $m$ from Process~A, either it already received $m$
  from Process~A; or it did not received $m$ from any process. In the former
  case, it cannot receive, hence deliver, $m$ from Process~A; in the latter
  case, receiving $m$ from Process~A leads to the delivery of $m$. Again, since
  a link conveys a message at most once, it cannot receive another $m$ from
  Process~A that would lead to another delivery.
\end{proof}


\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkA.tex}%
      \caption{\label{fig:memorylinkA}Process~B broadcasts $b$ and awaits a copy
        of $b$ from Process~A.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkB.tex}%
      \caption{\label{fig:memorylinkB}Process~A receives, delivers, and forwards
        $b$. It expects a copy from Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkC.tex}%
      \caption{\label{fig:memorylinkC}Process~B and Process~C receive $b$. They
        do not expect additional copies. Process~C delivers and forwards $b$.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkD.tex}%
      \caption{\label{fig:memorylinkD}Process~A receives its last expected copy
        of $b$. The message $b$ is completely removed from the system.}
    \end{subfigure}
    \caption{\label{fig:memorylink}Link memory allows processes to forget past
      deliveries in static systems.}
  \end{center}
\end{figure}



%Vector clocks implement remembering but fail to remove obsolete control
%information. 

Algorithm~\ref{algo:reliablebroadcast} shows an implementation of uniform
reliable broadcast that uses link memory to forbid multiple delivery in static
systems. The link memory is non-monotonic. The first receipt of a broadcast
message from a link tags the other links (see Line~\ref{line:remembers}). The
receipt on other links of this broadcast message removes the corresponding tag
(see Line~\ref{line:forgets}). Figure~\ref{fig:memorylink} depicts its
functioning in a system comprising 3 processes. In Figure~\ref{fig:memorylinkA},
Process~B broadcasts $b$. It awaits a copy of $b$ from the only link in its
in-view. In Figure~\ref{fig:memorylinkB}, Process~A receives $b$. It delivers
it, for no link in its in-view is tagged with $b$, meaning this is a first
receipt. It tags the other link in its in-view with $b$ and forwards $b$ to its
out-view. In Figure~\ref{fig:memorylinkC}, Process~B receives the awaited copy
of $b$ from Process~A. It removes the corresponding entry. Process~B does not
consume space anymore for reliable broadcast. Process~C receives $b$. It detects
a first receipt so it delivers and forwards $b$. It does not tag any link, for
the only link from its in-view is the link from which it just received $b$. In
Figure~\ref{fig:memorylinkD}, the last process to await a copy of $b$ finally
receives it. None of processes remembers about $b$. No copy of $b$ travels in
the system. This implementation forbids multiple delivery in static systems.

However, implementing link memory becomes more challenging in dynamic systems
where processes can start sending messages to any other process at any time. Any
process can receive an already forgotten message from any other
process. Figure~\ref{fig:memorylinkfails} illustrates the issue. In
Figure~\ref{fig:memorylinkfailsA}, Process~A broadcasts $a$. It expects a copy
from both Process~B and Process~C. In Figure~\ref{fig:memorylinkfailsB},
Process~C immediately receives, delivers, and forwards $a$. It does not tag any
link and expects to never receive this message again. However, network condition
delays the receipt of $b$ from Process~B. In Figure~\ref{fig:memorylinkfailsC}
adds a communication link towards Process~C. Then it receives, delivers, and
forwards $b$. Since Process~C now belongs to its out-view, the forwarding
includes Process~C. In Figure~\ref{fig:memorylinkfailsD}, Process~C receives $a$
again. However, it did not keep control information about this message. It
mistakes it for a first receipt. It delivers and forwards $a$. Not only
Process~C suffers multiple delivery but this has cascading effects over the
whole system.

In this paper, we solve this issue by exploiting causal broadcast's ability to
ensure a specific order on message delivery. To characterize the order among
events such as send, or receive, we define time in a logical sense using
Lamportâ€™s definition.

\begin{definition}[Happen before~\cite{lamport1978time}]
  Happen before is a transitive, irreflexive, and antisymmetric relation
  $\rightarrow$ that defines a strict partial orders of events. The sending of a
  message always precedes its receipt $s_{AB}(m) \rightarrow r_{BA}(m)$. Two
  messages are concurrent if none happens before the other.
\end{definition}

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts.
  $d_A(m) \rightarrow b_A(m') \implies d_B(m) \rightarrow d_B(m')$
\end{definition}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsA.tex}%
      \caption{\label{fig:memorylinkfailsA}Process~A broadcasts $a$ and expects a copy
        from both Process~B and Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsB.tex}%
      \caption{\label{fig:memorylinkfailsB}Process C receives, delivers, and
        forwards $a$. It does not expect additional copies.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsC.tex}%
      \caption{\label{fig:memorylinkfailsC}Process~B adds a link to Process~C. 
        Then it receives, delivers, and forwards $a$.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsD.tex}%
      \caption{\label{fig:memorylinkfailsD}Process~C receives and mistakes $a$
        for a new message. It delivers, and forwards $a$.}
    \end{subfigure}
    \caption{\label{fig:memorylinkfails}Reliable broadcast
      (Algorithm~\ref{algo:reliablebroadcast}) fails to forbid multiple delivery
      in dynamic systems. }
  \end{center}
\end{figure}




% \begin{figure}
%   \begin{center}
%     \input{input/figtimelinepcbroadcast.tex}
%     \caption{\label{fig:timelinepcbroadcast}Process~A ensures the safety of a
%       link to Process~B. $\pi$ travels using safe links through intermediary
%       processes that are hidden for the sake of clarity. $\rho$ reaches
%       Process~A by any communication mean. Process~A sends the array of buffered
%       messages via the new link. The link becomes safe.}
%   \end{center}
% \end{figure}

% \begin{problem*}
%   Figure~\ref{fig:problemstatement} depicts this problem. Assuming Process~A
%   sends a buffer of messages to Process~B in order to finalize the safety of
%   this link. Upon receipt of this buffer by Process~B, the scientific problem
%   consists in:
%   \begin{itemize}[leftmargin=*]
%   \item Identifying the array of messages from the buffer that are delivered by
%     Process~A but not delivered by Process~B in order to deliver them;
%   \item Identifying the set of messages from the buffer that are delivered by
%     Process~A and Process~B in order to forget them;
%   \item Identifying the set of messages delivered by Process~B that Process~B will
%     receive by this safe link in order to remember them.
%   \end{itemize}%
% %  These are the array of messages to deliver, the set of messages to ignore, and
% %  the set of messages to expect, respectively.
% \end{problem*}

% \begin{figure}
%   \begin{center}
%     \input{input/figproblemstatement.tex}
%     \caption{\label{fig:problemstatement}For each message in the buffer,
%       Process~B must identify its category and assign awaited messages on the
%       new safe link.}
%   \end{center}
% \end{figure}

The rest of this section describes how reliable broadcast can exploit causal
order to initialize safe link memory. Then, we provide an implementation of such
broadcast along with its complexity analysis.

\subsection{Principle}

This section demonstrates that reliable broadcast can use causal order brought
by causal broadcast to initialize safe link memory, hence provide a
non-monotonic local structure that removes all and only obsolete information in
large and dynamic systems.

Figure~\ref{fig:memorylink} shows that Algorithm~\ref{algo:reliablebroadcast}
already implements the maintenance of link memory over receipts. Processes
discard obsolete control information over receipts.  However,
Figure~\ref{fig:memorylinkfails} shows that new links lack of consistent
initialization. The challenge consists in initializing such memory without
history of past messages. Causal broadcast starts to build the knowledge
on-demand, i.e., when a process wants to add a link to another process.  The
protocol disables the new link until it is initialized. This initialization
requires round-trips of control messages and message buffering.  Causal
broadcast takes advantage of causal order to provide guarantees on messages
included in buffers.

% \begin{figure*}
%   \begin{center}
%     \input{input/figtimelinerpcbroadcast.tex}
%     \caption{\label{fig:timeline}Timeline of \RPCBROADCAST when Process~A adds a
%       link to Process~B in its out-view. We hide intermediate processes for the
%       purpose of clarity. Messages arrive in causal order.}
%   \end{center}
% \end{figure*}

\begin{figure}
  \begin{center}
    \input{input/figtimelineproof.tex}
    \caption{\label{fig:timelineproof}\label{fig:timeline}Initializing the link
      memory from Process~A to Process~B. Control messages $\alpha$, $\beta$,
      $\pi$, and $\rho$ are delivered in causal order while $B_\beta$ is not.
      $B_\beta \cap (B_\alpha \cup B_\pi) = \mathcal{B}_2 \cup \mathcal{A}_3'$
      are messages to ignore;
      $B_\beta \setminus B_\alpha \setminus B_\pi = \mathcal{A}_3\setminus
      \mathcal{A}_3'$
      are messages to deliver; $B_\pi \setminus B_\beta = \mathcal{B}_3$ are
      messages to expect.}
  \end{center}
\end{figure}


Figure~\ref{fig:timelineproof} depicts the principle of the approach. When a
Process~A adds a link to
Process~B. %, \RPCBROADCAST initializes safe link memory
% in 3 steps.
Process~A notifies Process~B using a control message $\alpha$. This control
message $\alpha$, as all control messages that will follow ($\beta$, $\pi$,
$\rho$), are delivered in causal order regarding broadcast messages. Hence, at
receipt, Process~B implicitly removes obsolete information: messages delivered
by Process~A before the sending of the notification $\mathcal{A}_1$. 
At receipt
of $\alpha$, Process~B can start gathering control information about its
delivered messages in a buffer $B_\alpha$. Among other, Process~B wants to
identify messages concurrent to the correct establishment of the new
link. Process~B acknowledges Process~A's notification using a control message
$\beta$. At receipt of $\beta$, Process~A removes obsolete information: messages
delivered by Process~B before the sending of the acknowledgment
$\mathcal{A}_1 \cup \mathcal{B}_1$. This solves the issue
identified in Figure~\ref{fig:memorylinkfails}, for $a$ would belong to $\mathcal{A}_1$
or $\mathcal{B}_1$. However, this is not sufficient to initialize link memory.
Process~A sends a control message $\pi$ to
Process~B, and starts to gather control information about its delivered messages
in a buffer $B_\beta$. Upon receipt of $\pi$, Process~B closes its first buffer
$B_\alpha$.
  
\begin{lemma}[\label{lem:balpha}Messages in buffer $B_\alpha$]
  The buffer $B_\alpha$ contains messages delivered by Process~B after the
  sending of $\beta$ and before the receipt of $\pi$.\\
  This includes all messages delivered by Process~A before the sending of $\pi$
  that were not delivered by Process~B before the sending of $\beta$:
  $\mathcal{A}_2$. Most importantly, this also includes all messages delivered
  by Process~B that were not delivered by Process~A at the sending of $\pi$:
  $\mathcal{B}_2$.
\end{lemma}

\begin{proof}
  Since causal broadcast ensures causal order among messages it conveys, all
  messages delivered by Process~A before the sending of $\alpha$ precede the
  buffering:
  $\forall m,\, d_A(m) \rightarrow s_A(\alpha_{AB}) \implies m \not \in
  B_\alpha$.
  Since messages are delivered once,
  $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge d_B(m) \rightarrow
  s_B(\beta_{AB}) \implies m \not \in B_\alpha$.
  This removes $\mathcal{A}_1$ and $\mathcal{B}_1$.\\
  The buffer $B_\alpha$ contains the rest of messages delivered by Process~B
  before the receipt of $\pi$. This includes messages delivered by Process~A
  between the sending of $\alpha$ and $\pi$ but not delivered by Process~B
  before the sending of $\beta$ ($\mathcal{A}_2$); and messages delivered by
  Process~B but not delivered by Process~A before the sending of $\pi$
  ($\mathcal{B}_2$).
\end{proof}

\noindent Upon receipt of $\pi$, Process~B continues to gather control information about
its delivered messages in another buffer $B_\pi$. Some messages in this buffer
will be expected from Process~A, but Process~B cannot determine which ones just
yet. It sends the last acknowledgment $\rho$ to Process~A. Upon receipt of this
acknowledgment, Process~A closes its buffer and sends it using the new
link. Afterwards, Process~A uses the new link for causal broadcast, for it knows
that Process~B will receive $B_\beta$ before upcoming broadcast messages on this
new link, and the receipt of $B_\beta$ will allow Process~B to initialize this
new link memory.

\begin{lemma}[\label{lem:bbeta}Messages in buffer $B_\beta$]
  The buffer $B_\beta$ contains messages delivered by Process~A after the
  sending of $\pi$ and before the receipt of $\rho$.\\
  This includes all messages delivered by Process~B before the sending of
  $\rho$ that were not delivered by Process~A before the sending of $\pi$:
  $\mathcal{B}_2$. This also includes all messages delivered by Process~A that
  were not delivered by Process~B at the sending of $\rho$: $\mathcal{A}_3$.
\end{lemma}
  
\begin{proof}
  The proof is similar to that of Lemma~\ref{lem:balpha}. Control messages
  shift roles. $\pi$ becomes $\rho$; $\beta$ becomes $\pi$; $\alpha$ becomes
  $\beta$.
\end{proof}

\noindent Upon receipt of $B_\beta$, Process~B stops buffering in $B_\pi$.
  
\begin{lemma}[\label{lem:bpi}Messages in buffer $B_\pi$]
  The buffer $B_\pi$ contains messages delivered by Process~B after the
  sending of $\pi$ and before the receipt of $B_\beta$.\\
  This may includes messages delivered by Process~A before the sending of
  $B_\beta$ that were not delivered by Process~B before the sending of $\rho$:
  $\mathcal{A}_3'$. This also includes all messages delivered by Process~B that
  were not delivered by Process~A at the sending of $B_\beta$:
  $\mathcal{B}_3$. 
\end{lemma}

\begin{proof}
  The proof is similar to that of Lemmas~\ref{lem:bbeta}~and~\ref{lem:bpi}. The
  difference being that $B_\beta$ is not causally delivered. Hence, the receipt
  of $B_\beta$ follows the sending of $\rho$ but Process~B cannot state if it
  received all, part, or none of messages in $\mathcal{A}_3$. Thus,
  $\mathcal{A}_3' \subseteq \mathcal{A}_3$.
\end{proof}

\noindent Using $B_\alpha$, $B_\beta$, and $B_\pi$ buffers, Process~B identifies
messages in $B_\beta$ it must deliver against messages it must ignore, and
messages in $B_\pi$ it must receive from Process~A. This allows Process~B to
initialize link memory.

\begin{theorem}[$B_\alpha$, $B_\beta$, and $B_\pi$ build link memory]
  The memory of a new link becomes correct at receipt of $B_\beta$.
\end{theorem}

\begin{proof}
  From Lemma~\ref{lem:balpha}, $B_\alpha = \mathcal{A}_2 \cup \mathcal{B}_2$.
  From Lemma~\ref{lem:bbeta}, $B_\beta= \mathcal{B}_2 \cup \mathcal{A}_3$. From
  Lemma~\ref{lem:bpi}, $B_\pi = \mathcal{A}_3' \cup \mathcal{B}_3$. \\ First,
  for the maintenance of link memory, we must show that Process~B delivers all
  and only messages from $B_\beta$ it did not deliver yet:
  $\mathcal{A}_3 \setminus \mathcal{A}_3'$. Since
  $B_\beta \setminus B_\alpha \setminus B_\pi = (\mathcal{B}_2 \cup
  \mathcal{A}_3) \setminus (\mathcal{A}_2 \cup \mathcal{B}_2) \setminus
  (\mathcal{A}_3' \cup \mathcal{B}_3) = \mathcal{A}_3 \setminus \mathcal{A}_3'
  \cup \mathcal{B}_3 = \mathcal{A}_3'\setminus \mathcal{A}_3$
  (since $\mathcal{B}_3 \cap \mathcal{A}_3 = \varnothing$), Process~B identifies
  the set of messages to deliver using $B_\alpha$, $B_\beta$, and $B_\pi$. \\
  Second, for the initialization of link memory, we must show that Process~B
  initializes the new link memory with all and only messages from $B_\pi$ that
  Process~A did not deliver at the sending of $B_\beta$:
  $m \in \mathcal{B}_3 \Leftrightarrow d_B(m) \neg r_{BA}(m)$ and
  $m \in \mathcal{B}_3 \implies r_{BA}(m)$.  Since
  $B_\pi \cap B_\alpha = \varnothing$,
  $B_\pi \setminus (B_\beta \setminus B_\alpha)= B_\pi \setminus B_\beta =
  (\mathcal{A}_3' \cup \mathcal{B}_3) \setminus (\mathcal{B}_2 \cup
  \mathcal{A}_3) = \mathcal{B}_3$
  (since $\mathcal{B}_3 \cap \mathcal{B}_2 = \varnothing$ and
  $\mathcal{A}_3' \subseteq \mathcal{A}_3$), Process~B identifies the set of
  messages to await from Process~A using $B_\pi$ and $B_\beta$. This is the new
  link memory.
\end{proof}

\subsection{Implementation}

\RPCBROADCAST stands for Preventive Reliable Causal broadcast. It prevents
causal order violation and multiple delivery by using all and only links that
\begin{inparaenum}[(i)]
\item have been proven safe to use and
\item the memory of which is correctly initialized and maintained.
\end{inparaenum}
This guarantees causal order and non-monotonic local data structure in large and
dynamic systems. 

%% Table~\ref{table:complexity} shows that it keeps constant size message overhead
%% while discarding local control information about messages over receipts.

To provide causal order at marginal cost, \RPCBROADCAST uses the principle of
\PCBROADCAST~\cite{nedelec2018pcbroadcast}. It uses FIFO links, gossiping,
control messages, and buffers to ensure causal order in dynamic systems. A
process broadcasting a message sends the message to an out-view of safe links
that cannot lead to causal order violations. \RPCBROADCAST embeds safe link
establishment in its link memory initialization.

\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveA.tex}%
      \caption{\label{fig:solveA}Process~B adds a link to
        Process~C. \RPCBROADCAST ensures its safety. Process~B sends a first
        control message $\alpha$ to Process~C using Process~A as mediator.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveB.tex}%
      \caption{\label{fig:solveB}Process~A receives $\alpha$ and routes it to
        Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveC.tex}%
      \caption{\label{fig:solveC}Process~C receives $\alpha$ and answers by
        sending $\beta$ to Process~B using Process~A as mediator. Then,
        Process~C broadcasts $c_1$ and registers it in $B_\alpha$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveD.tex}%
      \caption{\label{fig:solveD}Process~A receives $\beta$ and routes it to
        Process~B.  Process~A receives $c_1$ and forwards it to both its
        neighbors.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveE.tex}%
      \caption{\label{fig:solveE}Process~C receives and discards
        $c_1$.  Process~B receives $\beta$ and replies $\pi$ to
        Process~C using Process~A as mediator.  Process~B receives
        $c_1$ and forwards it to its neighbor.  Process~B broadcasts
        $b_1$. It registers $c_1$ and $b_1$ in $B_\beta$.}
    \end{subfigure}    
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveF.tex}%
      \caption{\label{fig:solveF}Process~A receives $c_1$ and discards it.
        Process~A receives $\pi$ and routes it to Process~C. Process~A receives
        $b_1$ and forwards it to its neighbors. Process~C broadcasts $c_2$ and
        registers it in $B_\alpha$}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveG.tex}%
      \caption{\label{fig:solveG}Process~A receives $c_2$ and forwards it to
        its neighbors.  Process~B broadcasts $b_2$ and registers it in
        $B_\beta$. Process~C receives $\pi$ and replies $\rho$ to Process~B
        using Process~A as mediator. Then it receives and forwards $b_1$. Then
        it broadcasts $c_3$. It registers $b_1$ and $c_3$ in $B_\pi$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveH.tex}%
      \caption{\label{fig:solveH}Process~A receives and discards $b_1$.
        Process~A receives and routes $\rho$ to Process~B.  Process~A receives
        and forwards $b_2$ then $c_3$. Process~B receives, forwards, and
        registers $c_2$. Then Process~B receives $\rho$ and sends $B_\beta$ to
        Process~C using the new link.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveI.tex}%
      \caption{\label{fig:solveI}Once Process~A sent $B_\beta$, the new link is
        safe.  Process~C receives $B_\beta$. Process~C does not deliver $c_1$, $b_1$
        and $c_2$, for it already delivered them. Process~C delivers $b_2$ and
        expects another copy from Process~A, for it constitutes a new message.
        Process~C expects to eventually receive $c_3$ from Process~B.}
    \end{subfigure}
    \begin{subfigure}[t]{0.99\textwidth}
      \centering\input{input/figsolveJ.tex}%
      \caption{\label{fig:solveJ}Process~C categorizes each message of $B_\beta$
        and $B_\pi$ to maintain and initialize safe link memory.}
    \end{subfigure}
    \caption{\label{fig:solve}Using buffers and control messages, \RPCBROADCAST 
      provides reliable causal broadcast.}
  \end{center}
\end{figure}

\begin{algorithm}[h]
  \input{./input/algorpcbroadcast.tex}
  \caption{\label{algo:rpcbroadcast}\RPCBROADCAST at Process $p$.}
\end{algorithm}


Algorithm~\ref{algo:rpcbroadcast} shows the instructions of \RPCBROADCAST. 
Figure~\ref{fig:solve} illustrates its operation in a scenario involving 3
processes. In this example, Process~B adds a link to Process~C. Process~B
disables the new link for causal broadcast until it is safe and guaranteed that
Process~C correctly initialized its memory.

\noindent Process~B sends a first control message $\alpha$ to Process~B using
safe links (see Line~\ref{line:sendalpha} and Figure~\ref{fig:solveA}).

\noindent After being routed to Process~C by intermediary processes (see
Figure~\ref{fig:solveB}), $\alpha$ reaches Process~C (see
Figure~\ref{fig:solveC}).  Process~C starts to register messages it delivers in
a buffer $B_\alpha$.  Process~C acknowledges the receipt of $\alpha$ by sending
a second control message $\beta$ to Process~B using safe links (see
Line~\ref{line:sendbeta}). In Figure~\ref{fig:solveC}, Process~C broadcasts
$c_1$ and registers it in $B_\alpha$.

\noindent After being routed to Process~B (see Figure~\ref{fig:solveD}), $\beta$
reaches Process~B. Process~B starts to register messages it delivers in a buffer
$B_\beta$. Process~B sends a third control message $\pi$ to Process~C using safe
links (see Line~\ref{line:sendpi}). In Figure~\ref{fig:solveE}, Process~B delivers
$c_1$ then broadcasts $b_1$. It registers them in $B_\beta$. In Figure~\ref{fig:solveF},
Process~C broadcasts $c_2$ and registers it in $B_\alpha$.

\noindent After being routed to Process~C by intermediary processes (see
Figure~\ref{fig:solveF}), $\pi$ reaches Process~C. Process~C ends its first
buffer $B_\alpha$.  Process~C starts to register messages it delivers in
$B_\pi$.  Process~C sends a fourth and last control message $\rho$ to Process~B
using safe links (see Line~\ref{line:sendrho}). In Figure~\ref{fig:solveG}
Process~C delivers $b_1$, broadcasts $c_3$, and registers them in $B_\pi$. In
the meantime, Process~B broadcasts $b_2$ and registers it in $B_\beta$.

\noindent After being routed to Process~B, $\rho$ reaches Process~B (see
Figure~\ref{fig:solveH}).  Process~B stops buffering and sends its buffer of
messages $B_\beta$ using the new link $s_{BC}(B_\beta)$ (see
Line~\ref{line:sendbuffer}). In Figure~\ref{fig:solveI}, this buffer contains
$b_1$, $b_2$, and $c_2$. The new link is safe. Process~B starts to use this link
normally for causal broadcast using Algorithm~\ref{algo:reliablebroadcast}.

\noindent Once Process~C receives the buffer, it ends its buffer $B_\pi$ (see
Figure~\ref{fig:solveI}). Using $B_\alpha$, and $B_\pi$, Process~C identifies
among messages from $B_\beta$ the array of messages to deliver (see
Line~\ref{line:todeliver}). In Figure~\ref{fig:solveJ}, this array only includes
$b_2$.  Using $B_\alpha$, and $B_\pi$, Process~C also identifies the set of
messages to ignore which is the rest of the buffer. In Figure~\ref{fig:solveJ},
this set includes $c_1$, $b_1$ and $c_2$. Finally, Process~C identifies among its own
delivered messages the messages to expect from Process~B (see
Line~\ref{line:toexpect}). In Figure~\ref{fig:solveJ}, this set includes $c_3$.
This set constitutes the memory of the new safe link.  Afterwards, messages
received by this new link are processed normally.


\RPCBROADCAST builds safe link memory using control messages that follow causal
order. Link memory forbids multiple delivery and implies non-monotonic space
complexity. In the next section, we analyze the complexity of our causal
broadcast implementation.

\subsection{Complexity}
\label{subsec:complexity}

In this section, we analyze the complexity of \RPCBROADCAST in terms of
broadcast message overhead, delivery execution time, local space consumption,
and number of control messages.

\noindent The \textbf{broadcast message overhead} is constant $O(1)$. Messages
must travel using FIFO links.

\noindent The \textbf{delivery execution time}, i.e., the time complexity of the
receipt function is $O(Q_i)$. It checks and update control information
associated to each link in the in-view.

\noindent The \textbf{local space consumption} depends on the size of buffers
and the size of the in-view. Each link in the in-view has its buffer of control
information about messages. A message appears in the structure after its first
receipt and disappears at its last receipt. So the local space complexity is
$O(Q_i.M)$ where $M$ is the number of messages already delivered that should be
received again from at least one process in $Q_i$. A process stores the control
information of a message during at most $D$ time where $D$ is the diameter of
the system. The local space consumption depends on the system (e.g. ring or tree
topologies do not consume any space) and its usage (e.g. when no process
broadcasts any message, processes do not consume any space).
% Similarly to \PCBROADCAST, the size of buffers may increase unbounded when
% intermediate processes are faulty. Control messages never reach their
% destination. \PCBROADCAST handles such crashes using a timeout and retry
% policy. Such strategy fits \RPCBROADCAST as well. Both involved processes can
% halt and retry the safety check of the new link. Either the origin process does
% not send its buffer $B_\beta$, or the destination process does not accept
% incoming messages. 

\noindent The overhead in terms of \textbf{number of control messages} per added
link in an out-view varies from $6$ to $4P^2$ depending on the overlay network;
$P$ being the number of processes in the system. It achieves $6$ messages when
Process~A adds Process~B using Process~C as mediator, and Process~B has
Process~A in its out-view.  It achieves $8$ control messages when peer-sampling
protocols build out-views using neighbor-to-neighbor
interactions~\cite{jelasity2007gossip,nedelec2017adaptive}. It achieves
$O(\log(P))$ control messages when peer-sampling protocols allows processes to
route their messages~\cite{jelasity2009tman,stoica2001chord}.  It achieves
$O(4P^2)$ control messages when Process~A adds Process~B without knowledge of
any route. Process~A and Process~B fall back to reliable broadcast instead of
routing to disseminate control messages.

This complexity analysis shows that \RPCBROADCAST proposes an original tradeoff
in terms of complexity. In systems allowing a form of routing, it constitutes an
advantageous tradeoff that depends on the actual system instead of past
deliveries. The next section describes an experiment highlighting the effects of
the system settings on the space consumed by processes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
