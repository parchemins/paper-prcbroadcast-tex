
\section{Proposal}
\label{sec:proposal}

In this section, we present a causal broadcast protocol providing an original
tradeoff in terms of complexity. It removes the last linear and monotonic upper
bound that remained on space complexity at the cost of few lightweight control
messages. The key idea consists in exploiting causal broadcast to improve its
underlying reliable broadcast.  It exploits causal order to remove batches of
obsolete information while reasoning about temporarily buffered broadcast
messages.

\subsection{Model}

A distributed system comprises a set of processes that can communicate with each
other using messages. Processes may not have full knowledge of the membership of
the system. Instead, processes build and maintain overlay networks: each process
updates a local partial view of logical communication links, i.e., a set of
processes to communicate with. The partial view is usually much smaller than the
actual system size. We speak of overlay networks, networks, or distributed
systems indifferently.

\begin{definition}[Overlay network]
  An overlay network $G: P \times E$ comprises a set of processes $P$ and a set
  of directed links $E: P \times P$.  An overlay network is static if both sets
  $P$ and $G$ are immutable. Otherwise, the overlay network is dynamic. An
  overlay network is unpartitioned if their exists a path -- i.e. a link or an
  array of links -- from any process to any other process. We only consider
  unpartitioned overlay networks.
\end{definition}

\begin{definition}[Process]
  A process runs a set of instructions sequentially. Processes communicate with
  each other using asynchronous message passing. A process~A can send a message
  to another process~B $s_{AB}(m)$, or to any process $s_A(m)$; receive a
  message from another process~B $r_{AB}(m)$, or from any process $r_A(m)$. A
  process sends messages to the set of links departing from it, called
  neighborhood, or partial view, or out-view $Q_o$. A process receives messages
  from the set of links arriving to it, called in-view $Q_i$.  Processes are
  faulty if they crash, otherwise they are correct. We do not consider byzantine
  processes.
\end{definition}

Causal broadcast relies on reliable broadcast that provides guarantees on
message delivery. Each process receives each broadcast message at least once and
delivers it once despite possible multiple receipts.

\begin{definition}[\label{def:reliablebroadcast}Uniform reliable broadcast] 
  When a process~A broadcasts a message to all processes of its system $b_A(m)$,
  each correct process~B eventually receives it and delivers it
  $d_B(m)$. Uniform reliable broadcast guarantees 3 properties:
  \begin{itemize}[leftmargin=*]
  \item Validity: If a correct process broadcasts a message, then it
    eventually delivers it.
  \item Uniform Agreement: If a process -- correct or not -- delivers a message,
    then all correct processes eventually deliver it.
  \item Uniform Integrity: A process delivers a message at most once, and only if
    it was previously broadcast.
  \end{itemize}
\end{definition}

% From validity and uniform agreement, each correct process receives each
% broadcast message at least once. From uniform integrity, each correct process
% delivers each broadcast message once despite possible multiple receipts.  This
% suggests a data structure ensuring uniqueness of messages such as sets or
% vectors. It allows processes to remember about prior delivery of messages in
% order to discard double receipts.

% \begin{definition}[Remembering]
%   A process starts to remember a message at its delivery:
%   $remember_A(m) \equiv d_A(m)$.  A process delivers only messages not yet
%   remembered: \\ $\not\exists m,\, remember_A(m) \rightarrow d_A(m)$.
% \end{definition}

% \begin{theorem}[\label{theo:rememberinganduniqueness}Remembering forbids
%   multiple delivery]
%   A process delivering only messages it does not remember delivers each received
%   message exactly once.
% \end{theorem}

% \begin{proof}
%   A process receiving a message either delivered this message or not. In the
%   former case, it already remembers the message, hence discards it. In the
%   latter case, it delivers the message for the first time and starts to remember
%   it. Subsequent receipts fall in the former case. Consequently, a process
%   delivers each message once and only once.
% \end{proof}

Definition~\ref{def:reliablebroadcast} suggests the use of data structures that
saves delivered messages to ignore additional receipts. In static systems, such
data structure can be non-monotonic~\cite{raynal2013distributed}. We define a
non-monotonic link-wise memory to forbid multiple delivery.

\begin{definition}[\label{def:memory}Link memory]
  A link from Process~A to Process~B remembers among Process~B's delivered
  messages those that will be received from Process~A; and forgets among
  Process~B's delivered messages those that will never be received from
  Process~A.\\
  $\forall m,\, remember_{BA}(m) \equiv d_B(m) \wedge \neg r_{BA}(m)$ \\
  $\forall m,\, remember_{BA}(m) \implies r_{BA}(m)$
\end{definition}


\begin{theorem}[Link memory forbids multiple delivery]
  Assuming that each link conveys each message at most once, link memory is
  sufficient to forbid multiple delivery.
\end{theorem}

\begin{proof}
  We must show that
  $\not\exists m, d_B(m) \rightarrow r_{BA}(m) \wedge r_{BA}(m) \rightarrow
  d_B(m)$.
  The delivery $d_B(m)$ implies a prior receipt $r_B(m)$.  To deliver $m$ after
  its receipt from Process~A, Process~B must not remember $m$ on this link.  If
  Process~B does not remember $m$ from Process~A, either it already received $m$
  from Process~A; or it did not received $m$ from any process. In the former
  case, it cannot receive, hence deliver, $m$ from Process~A; in the latter
  case, receiving $m$ from Process~A leads to the delivery of $m$. Again, since
  a link conveys a message at most once, it cannot receive another $m$ from
  Process~A that would lead to another delivery.
\end{proof}


\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkA.tex}%
      \caption{\label{fig:memorylinkA}Process~B broadcasts $b$ and awaits a copy
        of $b$ from Process~A.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkB.tex}%
      \caption{\label{fig:memorylinkB}Process~A receives, delivers, and forwards
        $b$. It expects a copy from Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkC.tex}%
      \caption{\label{fig:memorylinkC}Process~B and Process~C receive $b$. They
        do not expect additional copies. Process~C delivers and forwards $b$.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkD.tex}%
      \caption{\label{fig:memorylinkD}Process~A receives its last expected copy
        of $b$. The message $b$ is completely removed from the system.}
    \end{subfigure}
    \caption{\label{fig:memorylink}Link memory allows processes to forget past
      deliveries in static systems.}
  \end{center}
\end{figure}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

%Vector clocks implement remembering but fail to remove obsolete control
%information. 

Algorithm~\ref{algo:reliablebroadcast} shows an implementation of uniform
reliable broadcast that uses link memory to forbid multiple delivery in static
systems. The link memory is non-monotonic. The first receipt of a broadcast
message from a link tags the other links (see Line~\ref{line:remembers}). The
receipt on other links of this broadcast message removes the corresponding tag
(see Line~\ref{line:forgets}). Figure~\ref{fig:memorylink} depicts its
functioning in a system comprising 3 processes. In Figure~\ref{fig:memorylinkA},
Process~B broadcasts $b$. It awaits a copy of $b$ from the only link in its
in-view. In Figure~\ref{fig:memorylinkB}, Process~A receives $b$. It delivers
it, for no link in its in-view is tagged with $b$, meaning this is a first
receipt. It tags the other link in its in-view with $b$ and forwards $b$ to its
out-view. In Figure~\ref{fig:memorylinkC}, Process~B receives the awaited copy
of $b$ from Process~A. It removes the corresponding entry. Process~B does not
consume space anymore for reliable broadcast. Process~C receives $b$. It detects
a first receipt so it delivers and forwards $b$. It does not tag any link, for
the only link from its in-view is the link from which it just received $b$. In
Figure~\ref{fig:memorylinkD}, the last process to await a copy of $b$ finally
receives it. None of processes remembers about $b$. No copy of $b$ travels in
the system. This implementation forbids multiple delivery in static systems.

% Algorithm~\ref{algo:reliablebroadcast} shows an implementation of uniform
% reliable broadcast that forbids multiple delivery in static systems. It features
% a data structure that remembers messages (see Line~\ref{line:remembers}) but
% forgets them as soon as they cannot be received any longer by the process (see
% Line~\ref{line:forgets}).  It uses the in-view and exploits the property that
% each process sends each message exactly once to each neighbor in their
% out-view. It associates with each link from the in-view a set of expected
% messages. A process forgets expected messages over receipts.


% \begin{theorem}[Forgetting]
%   Assuming processes receive each message a finite number of times, remembering
%   a message from its delivery to its last receipt is necessary and sufficient to
%   forbid multiple delivery.
% \end{theorem}

% \begin{proof}
%   Assuming a finite series of $k$ receipts of a message $m$ at Process~A:
%   $r^1_A(m) \rightarrow r^2_A(m) \wedge r^2_A(m) \rightarrow r^3_A(m) \wedge
%   \ldots \wedge r^{k-1}_A(m) \rightarrow r^k_A(m)$. \\
%   We must show that if Process~A remembers $m$ from its delivery until its
%   $k^{th}$ receipt, then Process~A delivers $m$ once. The proof is similar to
%   that of Theorem~\ref{theo:rememberinganduniqueness}. After the $k^{th}$
%   receipt, Process~A never receives -- hence delivers -- $m$ again. Remembering
%   $m$ until the $k^{th}$ receipt is sufficient.\\
%   We also must show that if Process~A does not strictly remember $m$ from its
%   delivery to its $k^{th}$ receipt, then Process~A delivers $m$ multiple
%   times. Process~A delivers and remembers $m$ after its first receipt. Let
%   $1\leq j<k$. Process~A stops remembering $m$ after the $j^{th}$ receipt. When
%   Process~A receives $m$ for the $(j+1)^{th}$ time, it considers it as a new
%   message and delivers it again. This issue may repeat multiple times leading to
%   that many deliveries of $m$.
% \end{proof}


\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsA.tex}%
      \caption{\label{fig:memorylinkfailsA}Process~A broadcasts $a$ and expects a copy
        from both Process~B and Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsB.tex}%
      \caption{\label{fig:memorylinkfailsB}Process C receives, delivers, and
        forwards $a$. It does not expect additional copies.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsC.tex}%
      \caption{\label{fig:memorylinkfailsC}Process~B adds a link to Process~C. 
        Then it receives, delivers, and forwards $a$.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.23\textwidth}
      \centering\input{input/figmemorylinkfailsD.tex}%
      \caption{\label{fig:memorylinkfailsD}Process~C receives and mistakes $a$
        for a new message. It delivers, and forwards $a$.}
    \end{subfigure}
    \caption{\label{fig:memorylinkfails}Reliable broadcast
      (Algorithm~\ref{algo:reliablebroadcast}) fails to forbid multiple delivery
      in dynamic systems. }
  \end{center}
\end{figure}

However, implementing link memory becomes more challenging in dynamic systems
where processes can start sending messages to any other process at any time. Any
process can receive an already forgotten message from any other
process. Figure~\ref{fig:memorylinkfails} illustrates the issue. In
Figure~\ref{fig:memorylinkfailsA}, Process~A broadcasts $a$. It expects a copy
from both Process~B and Process~C. In Figure~\ref{fig:memorylinkfailsB},
Process~C immediately receives, delivers, and forwards $a$. It does not tag any
link and expects to never receive this message again. However, network condition
delays the receipt of $b$ from Process~B. In Figure~\ref{fig:memorylinkfailsC}
adds a communication link towards Process~C. Then it receives, delivers, and
forwards $b$. Since Process~C now belongs to its out-view, the forwarding
includes Process~C. In Figure~\ref{fig:memorylinkfailsD}, Process~C receives $a$
again. However, it did not keep control information about this message. It
mistakes it for a first receipt. It delivers and forwards $a$. Not only
Process~C suffers multiple delivery but this has cascading effects over the
whole system.

In this paper, we solve this issue by exploiting causal broadcast's ability to
ensure a specific order on message delivery. To characterize the order among
events such as send, or receive, we define time in a logical sense using
Lamportâ€™s definition.



% \begin{definition}[Per link remembering]
%   A process remembers a message from its delivery to its last receipt, i.e.,
%   once the process received the message from its whole in-view.
%   $remember_B(m) \equiv \exists A \in Q_i,\, r_B(m) \wedge \neg r_{BA}(m)$
% \end{definition}

% \begin{lemma}[Per link remembering ensures delivery uniqueness]
%   Assuming a static network where processes cannot join, nor leave, nor
%   self-reconfigure their partial views, per link remembering ensures uniqueness
%   of delivery.
% \end{lemma}

% \begin{proof}
%   When a process receives a message $m$ for the first time, it expects to
%   receive one copy of $m$ for each other neighbor in its in-view. Assuming $k$
%   neighbors in its in-view, the process remembers $m$ until it receives $k$
%   copies in total. Assuming that each process delivers -- hence forwards -- each
%   message exactly once, the former process does not receive more than $k$ copies
%   of $m$. Consequently, each process deliver each message exactly once despite
%   receiving multiple copies.
% \end{proof}

% Algorithm~\ref{algo:reliablebroadcast} guarantees exactly once delivery of
% messages in static systems. The local data structure is safely purged over
% receipts. 

% In addition to reliable delivery, broadcast protocols can guarantee a delivery
% order of messages. We focus on causal order. Process~A should deliver a message
% $m$ from Process~B after having delivered all messages delivered by Process~B
% before the sending of $m$. This order will prove useful to ensure the receipt of
% set of messages. %\TODO{Explain that ordering messages will be usefull for us?}

\begin{definition}[Happen before~\cite{lamport1978time}]
  Happen before is a transitive, irreflexive, and antisymmetric relation
  $\rightarrow$ that defines a strict partial orders of events. The sending of a
  message always precedes its receipt $s_{AB}(m) \rightarrow r_{BA}(m)$. Two
  messages are concurrent if none happens before the other.
\end{definition}

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts.
  $d_A(m) \rightarrow b_A(m') \implies d_B(m) \rightarrow d_B(m')$
\end{definition}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}



% \begin{figure}
%   \begin{center}
%     \input{input/figtimelinepcbroadcast.tex}
%     \caption{\label{fig:timelinepcbroadcast}Process~A ensures the safety of a
%       link to Process~B. $\pi$ travels using safe links through intermediary
%       processes that are hidden for the sake of clarity. $\rho$ reaches
%       Process~A by any communication mean. Process~A sends the array of buffered
%       messages via the new link. The link becomes safe.}
%   \end{center}
% \end{figure}

% \subsection{Problem statement}
% \label{subsec:problemstatement}


%
% Links start unsafe, for messages traveling by the new links may arrive before
% preceding messages that took longer paths. \PCBROADCAST ensures safety by
% sending control messages. Section~\ref{sec:motivations} described its
% functioning. Process~A sends a control message $\pi$ to Process~B using safe
% links and awaits its answer $\rho$. This is a ping phase. While awaiting
% Process~B's response, Process~A buffers its delivered messages. Upon receipt of
% $\rho$, Process~A empties its buffer to Process~A. The link is safe. Process~A
% can use it normally for causal broadcast.
%
% \begin{definition}[Ping phase (\REF)]
%   Ping phase starts when Process~A pings Process~B. Ping messages $\pi$ travel
%   using safe links. When Process~B receives this ping, it replies to
%   Process~A. Replies $\rho$ travel using any communication mean. Ping phase ends
%   when Process~A receives the reply of Process~B.
% \end{definition}
%
% \begin{lemma}[\label{lemma:ping}Ping phases acknowledge broadcast receipts (\REF)]
%   A ping phase from Process~A to Process~B acknowledges the receipt by B of all
%   messages delivered by Process~A before this ping phase.
%   $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge r_A(\rho_{AB}) \implies
%   r_B(m)$
% \end{lemma}
%
%\PCBROADCAST ensures that all preceding messages arrive before new messages by
%acknowledging the receipt of most messages while buffering messages concurrent
%to the acknowledgment. Processes receive all messages at least once and deliver
%them following causal order. 

% However, \PCBROADCAST does not forbid multiple delivery by itself. It relies on
% a reliable broadcast that either use vector clocks, or fails to handle dynamic
% systems.  In Figure~\ref{fig:counterproblem}, the issue comes from Process~C
% being unable to remember messages it will receive from Process~B's buffer (i.e.,
% the message $a$) while forgetting about messages it will never receive from
% Process~B (i.e., the message $b$).  To remove the last linear and monotonic
% upper bound that remains on space complexity, causal broadcast must forget
% obsolete control information and handle dynamic systems where processes can
% join, leave, or self-reconfigure their partial view.


% To provide a bound on remembering, upon receipt of a broadcast message, a
% process must
% \begin{inparaenum}[(i)]
% \item identify if it already delivered this message, and
% \item identify all other processes that will send it this message.
% \end{inparaenum}

% \begin{problem*}
%   Figure~\ref{fig:problemstatement} depicts this problem. Assuming Process~A
%   sends a buffer of messages to Process~B in order to finalize the safety of
%   this link. Upon receipt of this buffer by Process~B, the scientific problem
%   consists in:
%   \begin{itemize}[leftmargin=*]
%   \item Identifying the array of messages from the buffer that are delivered by
%     Process~A but not delivered by Process~B in order to deliver them;
%   \item Identifying the set of messages from the buffer that are delivered by
%     Process~A and Process~B in order to forget them;
%   \item Identifying the set of messages delivered by Process~B that Process~B will
%     receive by this safe link in order to remember them.
%   \end{itemize}%
% %  These are the array of messages to deliver, the set of messages to ignore, and
% %  the set of messages to expect, respectively.
% \end{problem*}

% \begin{figure}
%   \begin{center}
%     \input{input/figproblemstatement.tex}
%     \caption{\label{fig:problemstatement}For each message in the buffer,
%       Process~B must identify its category and assign awaited messages on the
%       new safe link.}
%   \end{center}
% \end{figure}

% Figure~\ref{fig:problemstatement} depicts the scientific problem. The buffer of
% messages sent by Process~A includes messages that are delivered by Process~A
% only. Process~B must deliver these messages normally. The buffer of messages
% also includes messages already delivered by Process~B. Process~B must remember
% these messages to discard them when the buffer arrives. Finally, Process~B
% delivered messages that Process~A did not deliver. Since each process delivers
% and forwards each message exactly once, Process~B will receive these messages by
% this new safe link. Process~B must remember these messages to discard them at
% their receipt.

The rest of this section describes how reliable broadcast can exploit causal
order to initialize safe link memory. Then, we provide an implementation of such
broadcast along with its complexity analysis.


%\subsection{A reliable causal broadcast}
\subsection{Causal improves reliable}

% Figure~\ref{fig:counterproblem} shows that adding safe links is insufficient to
% forbid multiple delivery. At any time, a process may receive messages it already
% forgot and deliver them again. To solve this, we provide each link with a memory
% that must be consistent with Process~B's past deliveries and upcoming receipts
% from this link.

% \begin{definition}[\label{def:extension}Safe link extension]
%   % In addition to Definition~\ref{def:safe}, a link from Process~A to Process~B
%   % is safe if it guarantees to Process~A that messages received by Process~B via
%   % this link are delivered exactly once.

%   A link from Process~A to Process~B is safe if Process~B differentiates among
%   its delivered messages the messages it will eventually receive via this new
%   link from the messages it will never receive via this new link.
% \end{definition}

% Definition~\ref{def:extension} implies that Process~B manages to distinguish
% messages it delivered that are not delivered by Process~A from messages it did
% not delivered that are just delivered by Process~A. The former constitutes
% messages Process~B expects to receive from the link while the latter constitutes
% messages Process~B receives for the first time and should
% deliver. Algorithm~\ref{algo:reliablebroadcast} maintains this knowledge over
% receipts. However, it may fail when processes add neighbors in their out-view
% (see Figure~\ref{fig:generalproblem}).

This section demonstrates that reliable broadcast can use causal order brought
by causal broadcast to initialize safe link memory, hence provide a
non-monotonic local structure that removes all and only obsolete information in
large and dynamic systems.

Figure~\ref{fig:memorylink} shows that Algorithm~\ref{algo:reliablebroadcast}
already implements the maintenance of link memory over receipts. Processes
discard obsolete control information over receipts.  However,
Figure~\ref{fig:memorylinkfails} shows that new links lack of consistent
initialization. The challenge consists in initializing such memory without
history of past messages. Causal broadcast starts to build the knowledge
on-demand, i.e., when a process wants to add a link to another process.  The
protocol disables the new link until it is initialized. This initialization
requires round-trips of control messages and message buffering.  Causal
broadcast takes advantage of causal order to provide guarantees on messages
included in buffers.

% It builds temporary buffers in order to remember messages as long as they might
% be received again, taking into account the dynamicity of the system. Using these
% buffers, a process is able to retrieve the knowledge about old messages to
% ignore, messages to expect, and new messages to deliver.

% \begin{definition}[Buffering phase]
%   Process~B starts and stops buffering upon receipt of control messages from
%   Process~A. Control messages are $\alpha$, $\beta$, and $\gamma$. Process~A
%   sends $\alpha$ to Process~B using safe links. Process~B starts buffering on
%   receipt of $\alpha$. Process~B sends $\beta$ to Process~A using any
%   communication means. Process~A sends $\gamma$ to Process~B using safe
%   links. Process~B stops buffering on receipt of $\gamma$.
%   The buffer $\mathcal{B}$ contains the messages delivered by Process~B.
%   $m \in \mathcal{B} \Longleftrightarrow 
%   (r_B(\alpha) \rightarrow d_B(m)) \wedge (d_B(m) \rightarrow r_B(\gamma))$
% \end{definition}

% \begin{lemma}[Messages of buffer]
%   A buffer $\mathbb{B}$ includes messages delivered by Process~A but not delivered by
%   Process~B before the receipt of $\alpha$. This excludes messages delivered by
%   Process~A before the sending of $\alpha$ and messages delivered by Process~B
%   before the receipt of $\alpha$.
%   $\forall m,\,m',\,(m\neq m'),\, s_A(\alpha) \rightarrow d_A(m) \wedge d_A(m)
%   \rightarrow s_A(\gamma) \wedge d_B(m') \rightarrow r_B(\alpha) \implies m \in
%   \mathcal{B}$
% \end{lemma}

% \begin{proof}
%   Since control messages $\alpha$ and $\gamma$ travel by reliable FIFO links,
%   the receipt of all messages delivered by Process~A before the sending of
%   $\alpha$ precedes the receipt of $\alpha$ by Process~B:\\
%   $\forall m,\, d_A(m) \rightarrow s_A(\alpha) \implies d_B(m) \rightarrow
%   r_B(m) \implies m \not\in \mathcal{B}$\\
%   \TODO{Not sure where we are going.}
% \end{proof}

% \begin{figure*}
%   \begin{center}
%     \input{input/figtimelinerpcbroadcast.tex}
%     \caption{\label{fig:timeline}Timeline of \RPCBROADCAST when Process~A adds a
%       link to Process~B in its out-view. We hide intermediate processes for the
%       purpose of clarity. Messages arrive in causal order.}
%   \end{center}
% \end{figure*}

\begin{figure}
  \begin{center}
    \input{input/figtimelineproof.tex}
    \caption{\label{fig:timelineproof}\label{fig:timeline}Initializing the link
      memory from Process~A to Process~B. Control messages $\alpha$, $\beta$,
      $\pi$, and $\rho$ are delivered in causal order while $B_\beta$ is not.
      $B_\beta \cap (B_\alpha \cup B_\pi) = \mathcal{B}_2 \cup \mathcal{A}_3'$
      are messages to ignore;
      $B_\beta \setminus B_\alpha \setminus B_\pi = \mathcal{A}_3\setminus
      \mathcal{A}_3'$
      are messages to deliver; $B_\pi \setminus B_\beta = \mathcal{B}_3$ are
      messages to expect.}
  \end{center}
\end{figure}


Figure~\ref{fig:timelineproof} depicts the principle of the approach. When a
Process~A adds a link to
Process~B. %, \RPCBROADCAST initializes safe link memory
% in 3 steps.
Process~A notifies Process~B using a control message $\alpha$. This control
message $\alpha$, as all control messages that will follow ($\beta$, $\pi$,
$\rho$), are delivered in causal order regarding broadcast messages. Hence, at
receipt, Process~B implicitly removes obsolete information: messages delivered
by Process~A before the sending of the notification $\mathcal{A}_1$. At receipt
of $\alpha$, Process~B can start gathering control information about its
delivered messages in a buffer $B_\alpha$. Among other, Process~B wants to
identify messages concurrent to the correct establishment of the new
link. Process~B acknowledges Process~A's notification using a control message
$\beta$. At receipt of $\beta$, Process~A removes obsolete information: messages
delivered by Process~B before the sending of the acknowledgment
$\mathcal{A}_1 \cup \mathcal{B}_1$. Process~A sends a control message $\pi$ to
Process~B, and starts to gather control information about its delivered messages
in a buffer $B_\beta$. Upon receipt of $\pi$, Process~B closes its first buffer
$B_\alpha$.
  
\begin{lemma}[\label{lem:balpha}Messages in buffer $B_\alpha$]
  The buffer $B_\alpha$ contains messages delivered by Process~B after the
  sending of $\beta$ and before the receipt of $\pi$.\\
  This includes all messages delivered by Process~A before the sending of $\pi$
  that were not delivered by Process~B before the sending of $\beta$:
  $\mathcal{A}_2$. Most importantly, this also includes all messages delivered
  by Process~B that were not delivered by Process~A at the sending of $\pi$:
  $\mathcal{B}_2$.
\end{lemma}

\begin{proof}
  Since causal broadcast ensures causal order among messages it conveys, all
  messages delivered by Process~A before the sending of $\alpha$ precede the
  buffering:
  $\forall m,\, d_A(m) \rightarrow s_A(\alpha_{AB}) \implies m \not \in
  B_\alpha$.
  Since messages are delivered once,
  $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge d_B(m) \rightarrow
  s_B(\beta_{AB}) \implies m \not \in B_\alpha$.
  This removes $\mathcal{A}_1$ and $\mathcal{B}_1$.\\
  The buffer $B_\alpha$ contains the rest of messages delivered by Process~B
  before the receipt of $\pi$. This includes messages delivered by Process~A
  between the sending of $\alpha$ and $\pi$ but not delivered by Process~B
  before the sending of $\beta$ ($\mathcal{A}_2$); and messages delivered by
  Process~B but not delivered by Process~A before the sending of $\pi$
  ($\mathcal{B}_2$).
\end{proof}

\noindent Upon receipt of $\pi$, Process~B continues to gather control information about
its delivered messages in another buffer $B_\pi$. Some messages in this buffer
will be expected from Process~A, but Process~B cannot determine which ones just
yet. It sends the last acknowledgment $\rho$ to Process~A. Upon receipt of this
acknowledgment, Process~A closes its buffer and sends it using the new
link. Afterwards, Process~A uses the new link for causal broadcast, for it knows
that Process~B will receive $B_\beta$ before upcoming broadcast messages on this
new link, and the receipt of $B_\beta$ will allow Process~B to initialize this
new link memory.

% Afterwards the link is safe to use by Process~A for causal broadcast (see
% Definition~\ref{def:safe}).

\begin{lemma}[\label{lem:bbeta}Messages in buffer $B_\beta$]
  The buffer $B_\beta$ contains messages delivered by Process~A after the
  sending of $\pi$ and before the receipt of $\rho$.\\
  This includes all messages delivered by Process~B before the sending of
  $\rho$ that were not delivered by Process~A before the sending of $\pi$:
  $\mathcal{B}_2$. This also includes all messages delivered by Process~A that
  were not delivered by Process~B at the sending of $\rho$: $\mathcal{A}_3$.
\end{lemma}
  
\begin{proof}
  The proof is similar to that of Lemma~\ref{lem:balpha}. Control messages
  shift roles. $\pi$ becomes $\rho$; $\beta$ becomes $\pi$; $\alpha$ becomes
  $\beta$.
\end{proof}

\noindent Upon receipt of $B_\beta$, Process~B stops buffering in $B_\pi$.
  
\begin{lemma}[\label{lem:bpi}Messages in buffer $B_\pi$]
  The buffer $B_\pi$ contains messages delivered by Process~B after the
  sending of $\pi$ and before the receipt of $B_\beta$.\\
  This may includes messages delivered by Process~A before the sending of
  $B_\beta$ that were not delivered by Process~B before the sending of $\rho$:
  $\mathcal{A}_3'$. This also includes all messages delivered by Process~B that
  were not delivered by Process~A at the sending of $B_\beta$:
  $\mathcal{B}_3$. 
\end{lemma}

\begin{proof}
  The proof is similar to that of Lemmas~\ref{lem:bbeta}~and~\ref{lem:bpi}. The
  difference being that $B_\beta$ is not causally delivered. Hence, the receipt
  of $B_\beta$ follows the sending of $\rho$ but Process~B cannot state if it
  received all, part, or none of messages in $\mathcal{A}_3$. Thus,
  $\mathcal{A}_3' \subseteq \mathcal{A}_3$.
\end{proof}

\noindent Using $B_\alpha$, $B_\beta$, and $B_\pi$ buffers, Process~B identifies
messages in $B_\beta$ it must deliver against messages it must ignore, and
messages in $B_\pi$ it must receive from Process~A. This allows Process~B to
initialize link memory.

\begin{theorem}[$B_\alpha$, $B_\beta$, and $B_\pi$ build link memory]
  The memory of a new link becomes correct at receipt of $B_\beta$.
\end{theorem}

\begin{proof}
  From Lemma~\ref{lem:balpha}, $B_\alpha = \mathcal{A}_2 \cup \mathcal{B}_2$.
  From Lemma~\ref{lem:bbeta}, $B_\beta= \mathcal{B}_2 \cup \mathcal{A}_3$. From
  Lemma~\ref{lem:bpi}, $B_\pi = \mathcal{A}_3' \cup \mathcal{B}_3$. \\ First,
  for the maintenance of link memory, we must show that Process~B delivers all
  and only messages from $B_\beta$ it did not deliver yet:
  $\mathcal{A}_3 \setminus \mathcal{A}_3'$. Since
  $B_\beta \setminus B_\alpha \setminus B_\pi = (\mathcal{B}_2 \cup
  \mathcal{A}_3) \setminus (\mathcal{A}_2 \cup \mathcal{B}_2) \setminus
  (\mathcal{A}_3' \cup \mathcal{B}_3) = \mathcal{A}_3 \setminus \mathcal{A}_3'
  \cup \mathcal{B}_3 = \mathcal{A}_3'\setminus \mathcal{A}_3$
  (since $\mathcal{B}_3 \cap \mathcal{A}_3 = \varnothing$), Process~B identifies
  the set of messages to deliver using $B_\alpha$, $B_\beta$, and $B_\pi$. \\
  Second, for the initialization of link memory, we must show that Process~B
  initializes the new link memory with all and only messages from $B_\pi$ that
  Process~A did not deliver at the sending of $B_\beta$:
  $m \in \mathcal{B}_3 \Leftrightarrow d_B(m) \neg r_{BA}(m)$ and
  $m \in \mathcal{B}_3 \implies r_{BA}(m)$.  Since
  $B_\pi \cap B_\alpha = \varnothing$,
  $B_\pi \setminus (B_\beta \setminus B_\alpha)= B_\pi \setminus B_\beta =
  (\mathcal{A}_3' \cup \mathcal{B}_3) \setminus (\mathcal{B}_2 \cup
  \mathcal{A}_3) = \mathcal{B}_3$
  (since $\mathcal{B}_3 \cap \mathcal{B}_2 = \varnothing$ and
  $\mathcal{A}_3' \subseteq \mathcal{A}_3$), Process~B identifies the set of
  messages to await from Process~A using $B_\pi$ and $B_\beta$. This is the new
  link memory.
\end{proof}



% To provide safe links that cannot violate causal order, \PCBROADCAST sends a
% buffer of messages $B_\beta$ after a round-trip of messages $\pi$ and $\rho$. In
% \RPCBROADCAST, the receiver maintains 2 buffers $B_\alpha$ and $B_\pi$ in order
% to categorize the messages in $B_\beta$. \RPCBROADCAST interlaces the buffering
% phases to reason about the content of buffers. At receipt of $B_\beta$, the
% process identifies messages to deliver, messages to ignore, and messages to
% expect. The latter initializes the new link memory.

% phases using control messages (see Figure~\ref{fig:timelineproof}) with the
% objective to identify from the buffer of messages


% One control message of a buffering phase becomes the control message of the next
% buffering phase.

% \begin{proof}
%   Figure~\ref{fig:timeline} exposes the different steps of this proof. Assuming
%   that Process~A adds Process~B in its out-view. Before sending $\alpha$,
%   Process~A delivered a set of messages $\mathcal{A}$. Since $\alpha$ travels
%   using causal communication, all messages delivered by Process~A at the moment
%   of the sending are delivered by Process~B at the moment of the receipt:
%   $\forall m,\, d_A(m) \rightarrow s_A(\alpha_{AB}) \implies d_B(m) \rightarrow
%   r_B(\alpha_{AB})$.
%   Thus, Process~B delivered a set of messages $\mathcal{B}$ that comprises
%   $\mathcal{A}$ and another set of delivered messages $\mathcal{A}'$ unknown to
%   Process~A at the moment of the sending. $\mathcal{A}$ and $\mathcal{A}'$ are
%   disjoint.\\
%   When Process~A receives $\beta$, it delivered $\mathcal{C}$ that comprises
%   $\mathcal{B}$ and $\mathcal{B}'$, $\mathcal{B}'$ being a set of messages
%   unknown to Process~B at the moment of the sending of $\beta$. \\
%   When Process~B receives $\pi$, it delivered $\mathcal{D}$ that comprises
%   $\mathcal{C}$ and $\mathcal{C}'$, $\mathcal{C}'$ being the set of messages
%   unknown to Process~A at the moment of the sending of $\pi$. Hence, Buffer
%   $B_\alpha$ contains the set of messages delivered between the sending of
%   $\beta$ and the receipt of $\pi$:
%   $\mathcal{D} \setminus \mathcal{B} = \mathcal{A} \cup \mathcal{A'} \cup
%   \mathcal{B}' \cup \mathcal{C'} \setminus (\mathcal{A} \cup \mathcal{A}') =
%   \mathcal{B}' \cup
%   \mathcal{C}'$. \\
%   When Process~A receives $\rho$, it delivered $\mathcal{E}$ that comprises
%   $\mathcal{D}$ and $\mathcal{D}'$, $\mathcal{D}'$ being a set of messages
%   unknown to Process~B at the moment of the sending of $\rho$. Hence, Buffer
%   $B_\beta$ contains the array of messages delivered between the receipt of
%   $\beta$ and the receipt of $\rho$:
%   $\mathcal{E} \setminus \mathcal{C} = \mathcal{C}' \cup \mathcal{D}'$.\\
%   When Process~B receives the buffer $B_\beta$, it delivered a set of messages
%   that follows the receipt of $\pi$. The buffer $B_\pi$ comprises a set of
%   messages $\mathcal{G}$ delivered by Process~A before the sending of $B_\beta$
%   and a set of messages $\mathcal{H}$ not delivered by Process~A before the
%   sending of $B_\beta$.
  
%   \noindent\textbf{To ignore:} Process~B ignores messages in $\mathcal{C}'$,
%   for they are
%   delivered by both processes: $B_\beta \setminus B_\alpha = \mathcal{D}'$.
%   $\mathcal{G}$ is a subset of the remaining $\mathcal{D}'$ that should be
%   ignored: $(B_\beta \setminus B_\alpha) \wedge B_\pi$.

%   \noindent \textbf{To deliver:} Process~B delivers messages in $\mathcal{D}'$
%   that it did not delivered yet:
%   $(B_\beta\setminus B_\alpha) \setminus B_\pi = \mathcal{D}' \setminus
%   \mathcal{G}$.
  
%   \noindent \textbf{To expect from Process~A:} Process~B expects messages that
%   are not in $\mathcal{D}'$:
%   $B_\pi \setminus (B_\beta \setminus B_\alpha) = \mathcal{H}$.  Assuming the
%   link is not removed, since $\mathcal{H}$ comprises messages delivered by
%   Process~B only, and since all processes eventually receive, deliver, and
%   forward all messages, Process~B will eventually receive all the expected
%   messages $\mathcal{H}$ from this link in causal order.
% \end{proof}

\subsection{Implementation}

\RPCBROADCAST stands for Preventive Reliable Causal broadcast. It prevents
causal order violation and multiple delivery by using all and only links that
\begin{inparaenum}[(i)]
\item have been proven safe to use and
\item the memory of which is correctly initialized and maintained.
\end{inparaenum}
This guarantees causal order and non-monotonic local data structure in large and
dynamic systems. 

%% Table~\ref{table:complexity} shows that it keeps constant size message overhead
%% while discarding local control information about messages over receipts.

To provide causal order at marginal cost, \RPCBROADCAST uses the principle of
\PCBROADCAST (\REF). It uses FIFO links, gossiping, control messages, and
buffers to ensure causal order in dynamic systems. A process broadcasting a
message sends the message to an out-view of safe links that cannot lead to
causal order violations. \RPCBROADCAST embeds safe link establishment in its
link memory initialization.

\begin{definition}[\label{def:safe}Safe link (\REF)]
  A link from Process~A to Process~B is safe if and only if Process~B received
  or will receive all messages delivered by Process~A before receiving any
  message that Process~A will
  deliver. $safe_{AB} \equiv \forall m,\, m',\, d_A(m) \rightarrow s_{AB}(m')
  \implies r_B(m) \rightarrow r_{BA}(m')$
\end{definition}

\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveA.tex}%
      \caption{\label{fig:solveA}Process~B adds a link to
        Process~C. \RPCBROADCAST ensures its safety. Process~B sends a first
        control message $\alpha$ to Process~C using Process~A as mediator.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveB.tex}%
      \caption{\label{fig:solveB}Process~A receives $\alpha$ and routes it to
        Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveC.tex}%
      \caption{\label{fig:solveC}Process~C receives $\alpha$ and answers by
        sending $\beta$ to Process~B using Process~A as mediator. Then,
        Process~C broadcasts $c_1$ and registers it in $B_\alpha$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveD.tex}%
      \caption{\label{fig:solveD}Process~A receives $\beta$ and routes it to
        Process~B.  Process~A receives $c_1$ and forwards it to both its
        neighbors.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveE.tex}%
      \caption{\label{fig:solveE}Process~C receives and discards
        $c_1$.  Process~B receives $\beta$ and replies $\pi$ to
        Process~C using Process~A as mediator.  Process~B receives
        $c_1$ and forwards it to its neighbor.  Process~B broadcasts
        $b_1$. It registers $c_1$ and $b_1$ in $B_\beta$.}
    \end{subfigure}    
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveF.tex}%
      \caption{\label{fig:solveF}Process~A receives $c_1$ and discards it.
        Process~A receives $\pi$ and routes it to Process~C. Process~A receives
        $b_1$ and forwards it to its neighbors. Process~C broadcasts $c_2$ and
        registers it in $B_\alpha$}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveG.tex}%
      \caption{\label{fig:solveG}Process~A receives $c_2$ and forwards it to
        its neighbors.  Process~B broadcasts $b_2$ and registers it in
        $B_\beta$. Process~C receives $\pi$ and replies $\rho$ to Process~B
        using Process~A as mediator. Then it receives and forwards $b_1$. Then
        it broadcasts $c_3$. It registers $b_1$ and $c_3$ in $B_\pi$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveH.tex}%
      \caption{\label{fig:solveH}Process~A receives and discards $b_1$.
        Process~A receives and routes $\rho$ to Process~B.  Process~A receives
        and forwards $b_2$ then $c_3$. Process~B receives, forwards, and
        registers $c_2$. Then Process~B receives $\rho$ and sends $B_\beta$ to
        Process~C using the new link.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveI.tex}%
      \caption{\label{fig:solveI}Once Process~A sent $B_\beta$, the new link is
        safe.  Process~C receives $B_\beta$. Process~C does not deliver $c_1$, $b_1$
        and $c_2$, for it already delivered them. Process~C delivers $b_2$ and
        expects another copy from Process~A, for it constitutes a new message.
        Process~C expects to eventually receive $c_3$ from Process~B.}
    \end{subfigure}
    \begin{subfigure}[t]{0.99\textwidth}
      \centering\input{input/figsolveJ.tex}%
      \caption{\label{fig:solveJ}Process~C categorizes each message of $B_\beta$
        and $B_\pi$ to maintain and initialize safe link memory.}
    \end{subfigure}
    \caption{\label{fig:solve}Using buffers and control messages, \RPCBROADCAST 
      provides reliable causal broadcast.}
  \end{center}
\end{figure}

\begin{algorithm}[h]
  \input{./input/algorpcbroadcast.tex}
  \caption{\label{algo:rpcbroadcast}\RPCBROADCAST at Process $p$.}
\end{algorithm}


Algorithm~\ref{algo:rpcbroadcast} shows the instructions of \RPCBROADCAST.
Figure~\ref{fig:solve} illustrates its operation in a scenario involving 3
processes. In this example, Process~B adds a link to Process~C. Process~B
disables the new link for causal broadcast until it is safe and guaranteed that
Process~C correctly initialized its memory.

\noindent Process~B sends a first control message $\alpha$ to Process~B using
safe links (see Line~\ref{line:sendalpha} and Figure~\ref{fig:solveA}).

\noindent After being routed to Process~C by intermediary processes (see
Figure~\ref{fig:solveB}), $\alpha$ reaches Process~C (see
Figure~\ref{fig:solveC}).  Process~C starts to register messages it delivers in
a buffer $B_\alpha$.  Process~C acknowledges the receipt of $\alpha$ by sending
a second control message $\beta$ to Process~B using safe links (see
Line~\ref{line:sendbeta}). In Figure~\ref{fig:solveC}, Process~C broadcasts
$c_1$ and registers it in $B_\alpha$.

\noindent After being routed to Process~B (see Figure~\ref{fig:solveD}), $\beta$
reaches Process~B. Process~B starts to register messages it delivers in a buffer
$B_\beta$. Process~B sends a third control message $\pi$ to Process~C using safe
links (see Line~\ref{line:sendpi}). In Figure~\ref{fig:solveE}, Process~B delivers
$c_1$ then broadcasts $b_1$. It registers them in $B_\beta$. In Figure~\ref{fig:solveF},
Process~C broadcasts $c_2$ and registers it in $B_\alpha$.

\noindent After being routed to Process~C by intermediary processes (see
Figure~\ref{fig:solveF}), $\pi$ reaches Process~C. Process~C ends its first
buffer $B_\alpha$.  Process~C starts to register messages it delivers in
$B_\pi$.  Process~C sends a fourth and last control message $\rho$ to Process~B
using safe links (see Line~\ref{line:sendrho}). In Figure~\ref{fig:solveG}
Process~C delivers $b_1$, broadcasts $c_3$, and registers them in $B_\pi$. In
the meantime, Process~B broadcasts $b_2$ and registers it in $B_\beta$.

\noindent After being routed to Process~B, $\rho$ reaches Process~B (see
Figure~\ref{fig:solveH}).  Process~B stops buffering and sends its buffer of
messages $B_\beta$ using the new link $s_{BC}(B_\beta)$ (see
Line~\ref{line:sendbuffer}). In Figure~\ref{fig:solveI}, this buffer contains
$b_1$, $b_2$, and $c_2$. The new link is safe. Process~B starts to use this link
normally for causal broadcast using Algorithm~\ref{algo:reliablebroadcast}.

\noindent Once Process~C receives the buffer, it ends its buffer $B_\pi$ (see
Figure~\ref{fig:solveI}). Using $B_\alpha$, and $B_\pi$, Process~C identifies
among messages from $B_\beta$ the array of messages to deliver (see
Line~\ref{line:todeliver}). In Figure~\ref{fig:solveJ}, this array only includes
$b_2$.  Using $B_\alpha$, and $B_\pi$, Process~C also identifies the set of
messages to ignore which is the rest of the buffer. In Figure~\ref{fig:solveJ},
this set includes $c_1$, $b_1$ and $c_2$. Finally, Process~C identifies among its own
delivered messages the messages to expect from Process~B (see
Line~\ref{line:toexpect}). In Figure~\ref{fig:solveJ}, this set includes $c_3$.
This set constitutes the memory of the new safe link.  Afterwards, messages
received by this new link are processed normally.


\RPCBROADCAST builds safe link memory using control messages that follow causal
order. Link memory forbids multiple delivery and implies non-monotonic space
complexity. In the next section, we analyze the complexity of our causal
broadcast implementation.

\subsection{Complexity}
\label{subsec:complexity}

In this section, we analyze the complexity of \RPCBROADCAST in terms of
broadcast message overhead, delivery execution time, local space consumption,
and number of control messages.

\noindent The \textbf{broadcast message overhead} is constant $O(1)$. Messages
must travel using FIFO links.

\noindent The \textbf{delivery execution time}, i.e., the time complexity of the
receipt function is $O(Q_i)$. It checks and update control information
associated to each link in the in-view.

\noindent The \textbf{local space consumption} depends on the size of buffers
and the size of the in-view. Each link in the in-view has its buffer of control
information about messages. A message appears in the structure after its first
receipt and disappears at its last receipt. So the local space complexity is
$O(Q_i.M)$ where $M$ is the number of messages already delivered that should be
received again from at least one process in $Q_i$. A process stores the control
information of a message during at most $D$ time where $D$ is the diameter of
the system. The local space consumption depends on the system (e.g. ring or tree
topologies do not consume any space) and its usage (e.g. when no process
broadcasts any message, processes do not consume any space).
% Similarly to \PCBROADCAST, the size of buffers may increase unbounded when
% intermediate processes are faulty. Control messages never reach their
% destination. \PCBROADCAST handles such crashes using a timeout and retry
% policy. Such strategy fits \RPCBROADCAST as well. Both involved processes can
% halt and retry the safety check of the new link. Either the origin process does
% not send its buffer $B_\beta$, or the destination process does not accept
% incoming messages. \TODO{Maybe position this paragraph in complexity and find
%   better outro.}

\noindent The overhead in terms of \textbf{number of control messages} per added
link in an out-view varies from $6$ to $4P^2$ depending on the overlay network;
$P$ being the number of processes in the system. It achieves $6$ messages when
Process~A adds Process~B using Process~C as mediator, and Process~B has
Process~A in its out-view.  It achieves $8$ control messages when peer-sampling
protocols build out-views using neighbor-to-neighbor
interactions~\cite{jelasity2007gossip,nedelec2017adaptive}. It achieves
$O(\log(P))$ control messages when peer-sampling protocols allows processes to
route their messages~\cite{jelasity2009tman,stoica2001chord}.  It achieves
$O(4P^2)$ control messages when Process~A adds Process~B without knowledge of
any route. Process~A and Process~B fall back to reliable broadcast instead of
routing to disseminate control messages.

This complexity analysis shows that \RPCBROADCAST proposes an original tradeoff
in terms of complexity. In systems allowing a form of routing, it constitutes an
advantageous tradeoff that depends on the actual system instead of past
deliveries. The next section describes an experiment highlighting the effects of
the system settings on the space consumed by processes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
