 
\section{Introduction}

Causal broadcast constitutes the core communication primitive of many
distributed systems~\cite{hadzilacos1994modular}. Applications such as
distributed social networks~\cite{borthakur2013petabyte}, distributed
collaborative software~\cite{heinrich2012exploiting,nedelec2016crate}, or
distributed data
stores~\cite{bailis2013bolton,bravo2017saturn,demers1987epidemic,lloyd2011cops,shapiro2011comprehensive}
use causal broadcast to ensure consistency criteria.  Causal broadcast ensures
reliable receipt of broadcast messages, and exactly-once delivery following
Lamport's happen before relationship~\cite{lamport1978time}. When Alice comments
Bob's picture, nobody sees Alice's comment without Bob's picture, and nobody
sees multiple occurrences of Alice's comment or Bob's picture.
% If the sending of a message $m$ precedes the sending of a message $m'$ then all
% processes that deliver these two messages need to deliver $m$ before
% $m'$. Otherwise they deliver them in any order.

However, causal broadcast implementations do not scale in large and dynamic
systems comprising from hundreds to millions of processes joining, leaving, and
self-reconfiguring at any time.
%
%PASCAL: idea, gossip is for our proposal... keep it for our approach.
%In such context, Causal broadcast implementations rely on gossiping to efficiently propagate
%broadcast messages to all processes in dynamic systems comprising from hundreds
%to millions of processes joining, leaving, and self-reconfiguring at any
%time. 
%In such systems, as no process can afford to maintain an up-to-date knowledge
%of the full membership, ~\cite{birman1999bimodal,demers1987epidemic}. Instead,
%each process builds a partial view of neighbors to communicate
%with~\cite{jelasity2007gossip}. Gossiping exploits these neighborhoods to
%efficiently broadcast a message to all processes. To broadcast a message, a
%process sends the message to its neighbors; each process receiving such message
%forwards it to its own neighbors. Processes receive the message either directly
%or transitively.
%Processes may receive a broadcast message multiples times from different
%sources. 
Causal broadcast rely on reliable broadcast to forbid multiple
delivery~\cite{hadzilacos1994modular}. % Unfortunately, reliable broadcast
% implementations do not scale in large and dynamic systems.
Either they build a specific dissemination topology (e.g. tree or ring) that
ensures single receipt hence single
delivery~\cite{bravo2017saturn,raynal2013distributed} but such topologies are
difficult to maintain in dynamic systems subject to
failures~\cite{krasikova2016hashtable}; or they maintain a local structure to
identify and discard additional copies of an original message at receipt. These
structures are either based on physical
clocks~\cite{cachin2011introduction,demers1987epidemic} or on vectors of logical
clocks~\cite{malkhi2007concise,mukund2014optimized}. Physical clocks allow to
remove obsolete control information over time. However, they may remove useful
information leading to multiple deliveries with cascading effects in the
system. Vectors of logical clocks forbid multiple delivery in dynamic
systems. However, their size increases linearly and monotonically with the
number of processes that ever broadcast a message. Processes pay for their past
usage. They eventually become inefficient, for processes cannot safely reclaim
entries without running an overcostly distributed garbage collecting
protocol~\cite{abdullahi1998garbage}. State-of-the-art causal broadcast
implementations do not scale in large and dynamic systems.


\begin{table}
  \begin{center}
    \caption{\label{table:complexity} Complexity of broadcast algorithms at each
      process (detailed in Section~\ref{subsec:complexity}). $N$ the number of
      processes that ever broadcast a message. $P$ the number of processes in
      the system. $W$ the number of messages received but not delivered
      yet. $Q_i$ is the number of incoming communication means. $M$ is the number of
      messages already delivered that should be received again from at least one
      process in $Q_i$.}
  \input{input/tablecomplexity.tex}
  \end{center}
\end{table}

In this paper, we introduce an implementation of causal broadcast that belongs
to approaches forbidding multiple delivery by using local structures. A process
belongs to an overlay network and has neighbors to communicate with via incoming
and outgoing links.  Broadcast efficiently disseminates messages by
gossiping~\cite{jelasity2007gossip}: the broadcaster sends the message by its
outgoing links; each process receiving such message forwards it by its own
outgoing links. Processes receive the message either directly or
transitively. Our contribution is threefold:
\begin{itemize}[leftmargin=*]
\item We define link memory as a mean for each process to forbid multiple
  delivery using a non-monotonic local structure. Link memory allows each
  process to identify neighbors that will send a broadcast message while
  removing obsolete control information about broadcast messages that will never
  be received again. Assuming causal order, we prove that each process can build
  such knowledge even in dynamic systems where processes join, leave, or
  self-reconfigure their neighborhood at any time.
\item Our implementation provides an original tradeoff that actually depends on
  the system and its current usage. Quiescent systems suffer from no
  overhead. Table~\ref{table:complexity} shows that it keeps constant size
  overhead on messages while its space consumption is non-monotonic. It exploits
  causal order to purge all and only obsolete control information. This costs
  only few lightweight control messages in dynamic systems.  Our implementation
  does not maintain any specific topology. However, the number of control
  messages depends on routing capabilities of the system and its dynamicity. For
  instance, gossip-based peer-sampling
  protocols~\cite{jelasity2007gossip,jelasity2009tman,nedelec2017adaptive} need
  only 8 control messages per added link during periodic shuffles.
\item Our experiments highlight the space consumed and the traffic generated by
  our protocol in dynamic systems with varying latency. It confirms that the
  proposed approach scales with the system settings instead of past broadcast
  messages.
\end{itemize}
Instead of encoding the global state of the system in a vector of logical
clocks, our implementation only maintains its receipt state with its direct
neighborhood. Neighborhood being far smaller than the full system membership,
this scales in large and dynamic systems.  Our implementation offers an
advantageous tradeoff that makes causal broadcast a lightweight and efficient
middleware in large and dynamic systems. This tradeoff even makes a lightweight
and efficient implementation of reliable broadcast.

The rest of this paper is organized as follows. 
% Section~\ref{sec:motivations}
% shows the issue and motivates this work.
Section~\ref{sec:proposal} describes the model, highlights the issue, introduces
the principle solving the issue, provides an implementation solving the issue
along with its complexity analysis. Section~\ref{sec:experimentation} shows the
experiments. Section~\ref{sec:relatedwork} reviews related work. We conclude in
Section~\ref{sec:conclusion}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
