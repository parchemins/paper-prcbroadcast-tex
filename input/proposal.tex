
\section{Proposal}
\label{sec:proposal}

In this section, we present \RPCBROADCAST, a causal broadcast protocol removing
the last linear upper bound in terms of number of processes that ever broadcast
a message that remained on space complexity. \RPCBROADCAST exploits the
improvement brought by \PCBROADCAST on generated traffic to reduce the space
consumed by reliable broadcast, at marginal cost.

\subsection{Model}

A distributed system comprises a set of processes that can communicate with each
other using messages. Processes may not have full knowledge of the membership of
the system. Instead, processes build and maintain overlay networks: each process
updates a local partial view of logical communication channels, i.e., a set of
processes to communicate with. The partial view is usually much smaller than the
actual system size. We speak of overlay networks, networks, or distributed
systems indifferently.

\begin{definition}[Overlay network]
  An overlay network comprises a set of processes that run a set of instructions
  sequentially.  An overlay network also comprises a set of directed
  links. \\
  An overlay network is dynamic if the set of processes or the set of links is
  mutable. Otherwise, the overlay network is static. \\
  The set of links departing from a process is its neighborhood, or partial
  view, or out-view. The set of links arriving to a process is its in-view. \\
  A link from a process to another process allows the former to transmit
  information to the latter. Processes transmit information using asynchronous
  message passing.\\
  Processes are faulty if they crash, otherwise they are correct. There are no
  byzantine processes.
\end{definition}

Processes can communicate with each other using message passing. Process~A can
send a message $m$ to Process~B $s_{AB}(m)$. Process~A can receive a message $m$
from another process B $r_{AB}(m)$, or from any other process
$r_A(m)$. Process~A can send a message $m$ to all other processes of the system,
i.e., it broadcasts a message $b_A(m)$. Process~A can deliver a message
$d_A(m)$.

To characterize the order among events such as send, or receive, we define time
in a logical sense using Lamportâ€™s definition.

\begin{definition}[Happen before~\cite{lamport1978time}]
  Happen before is a transitive, irreflexive, and antisymmetric relation that
  defines a strict partial orders of events. The sending of a message always
  precedes its receipt $s_{AB}(m) \rightarrow r_{BA}(m)$. Two messages are
  concurrent if none happens before the other.
\end{definition}

\begin{definition}[Uniform reliable broadcast] 
  When a process broadcasts a message to all processes of the network, correct
  processes eventually receive it. Uniform reliable broadcast guarantees 3
  properties:
  \begin{itemize}
  \item Validity: If a correct process broadcasts a message, then it
    eventually delivers it.
  \item Uniform Agreement: If a process -- correct or not -- delivers a message,
    then all correct processes eventually deliver it.
  \item Uniform Integrity: A process delivers a message at most once, and only if
    it was previously broadcast.
  \end{itemize}
\end{definition}

From uniform integrity, we derive that despite multiple receipts, a process
delivers a message once.

\begin{definition}[Exactly once delivery]
  A process may receive each broadcast message multiple times but delivers it
  exactly once.
  $\forall m, \{r_A(m)\}^+ \rightarrow d_A(m) \wedge d_A(m) \not\rightarrow d_A(m) \wedge d_A(m) \rightarrow \{r_A(m)\}^*$
\end{definition}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast that purges its local structure over time but only in static
networks. The implementation uses the in-view and exploits the property that
each process sends each message exactly once to each neighbor in their
out-view. It associates with each link from the in-view a set of awaited
messages. When Process~A receives a message for the first time from Process~B,
it awaits a copy of this message from all other processes in its in-view. When
it receives such copy, it removes the message from the set of awaited messages
of the corresponding link. Process~A will never receive a copy of this message
from this link. Once it received all awaited copies, it will never receive a
copy of this message. The principle of this implementation is similar to that of
Figure~\ref{fig:generalpurge} to which it adds an awareness of links with
awaited messages. Using this reliable broadcast implementation, each process
delivers each message exactly once.

% \begin{lemma}[Exactly once receipt of links]
%   Processes receive a message exactly once from each link. 
% \end{lemma}

% \begin{proof}
%   Since processes deliver messages exactly once, and forward messages once per
%   delivery to their out-view, a process cannot receive more than one copy per
%   link of a message. 
% \end{proof}

In addition to reliable delivery, broadcast protocols can guarantee a delivery
order of messages. We focus on causal order. Process~A should deliver a message
$m$ from Process~B after having delivered all messages delivered by Process~B
before the sending of $m$.

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts.
  $d_A(m) \rightarrow b_A(m') \implies d_B(m) \rightarrow d_B(m')$
\end{definition}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

\PCBROADCAST (\REF) is a causal broadcast that uses \TODO{reliable ?} FIFO
links, control messages, and buffers to ensure causal order in dynamic
systems. A process broadcasting a message sends the message to an out-view of
safe links.

\begin{definition}[\label{def:safe}Safe link] 
  A link from Process~A to Process~B is safe if and only if Process~B received
  or will receive all messages delivered by Process~A before receiving any
  message that Process~A will
  deliver: $safe(AB) \equiv \forall m,\, m',\, d_A(m) \rightarrow s_{AB}(m')
  \implies r_B(m) \rightarrow r_{BA}(m')$
\end{definition}

Links start unsafe. \PCBROADCAST ensures that they are safe, i.e., they cannot
cause causal order violations, by sending control messages.

\begin{definition}[Ping phase]
  Ping phase starts when Process~A pings Process~B. Ping messages $\pi$ travel
  using safe links. When Process~B receives this ping, it replies to
  Process~A. Replies $\rho$ travel using any communication mean. Ping phase ends
  when Process~A receives the reply of Process~B.
\end{definition}

\begin{lemma}[\label{lemma:ping}Ping phases acknowledge broadcast receipts]
  A ping phase from Process~A to Process~B acknowledges the receipt by B of all
  messages delivered by Process~A before this ping phase:
  $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge r_A(\rho_{AB}) \implies
  r_B(m)$
\end{lemma}

% \begin{lemma}[Buffer $B$ \TODO{Move, does not make sense here yet}]
%   $\forall m,\, s_A(\pi_{AB}) \rightarrow d_A(m) \wedge d_A(m) \rightarrow r_A(\rho_{AB})
%   \Longleftrightarrow m \in B$
% \end{lemma}

In this paper, we extend the meaning of safe link to not only ensure causal
order but also exactly once delivery. This is more expensive to ensure, for it
must account for concurrent messages. \TODO{More}

%broadcast requires more ping phases and
%more buffers.


\subsection{Operation}

\begin{algorithm}[h]
  \input{./input/algorpcbroadcast.tex}
  \caption{\label{algo:rpcbroadcast}RPC-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:rpcbroadcast} shows the instructions of the proposed causal
broadcast. It relies on an implementation of reliable broadcast shown in
Algorithm~\ref{algo:reliablebroadcast}. When the process does not add links to
other processes, nor other processes add links to this process, causal broadcast
operation is that of reliable broadcast. 

In dynamic systems where processes can join, leave, or reconfigure their
out-view at any time, \RPCBROADCAST ensures that links cannot violate causal
broadcast properties. It extends Definition~\ref{def:safe} of safe links by
adding a clause about exactly once delivery. 

% When the process wants to add a link to another process for causal broadcast, it
% makes sure that this link cannot break the guaranty that the other process
% delivers each message exactly once in causal order. It extends the meaning of
% safe links stated by Definition~\ref{def:safe}.

\begin{definition}[\label{def:extension}Safe link extension]
  In addition to Definition~\ref{def:safe}, a link from Process~A to Process~B
  is safe if it guarantees to Process~A that messages received by Process~B via
  this link are delivered exactly once.
\end{definition}

Definition~\ref{def:extension} implies that Process~B manages to distinguish
messages it delivered that are not delivered by Process~A from messages it did
not delivered that are just delivered by Process~A. The former constitutes
messages Process~B expects to receive from the link while the latter constitutes
messages Process~B receives for the first time and should
deliver. Algorithm~\ref{algo:reliablebroadcast} maintains this knowledge over
receipts. However, it may fail when processes add neighbors in their out-view
(see Figure~\ref{fig:generalproblem}).

\RPCBROADCAST solves this problem by delaying the use of links for broadcast
until they become safe. It builds temporary buffers to retrieve the knowledge
about expected messages and new messages.

\begin{definition}[Buffering phase]
  Process~B starts and stops buffering upon receipt of control messages from
  Process~A. Control messages are $\alpha$, $\beta$, and $\gamma$. Process~A
  sends $\alpha$ to Process~B using safe links. Process~B starts buffering on
  receipt of $\alpha$. Process~B sends $\beta$ to Process~A using any
  communication means. Process~A sends $\gamma$ to Process~B using safe
  links. Process~B stops buffering on receipt of $\gamma$.
  The buffer contains the messages delivered by Process~B: \\
  $m \in B \Longleftrightarrow 
  r_B(\alpha) \rightarrow d_B(m) \wedge d_B(m) \rightarrow r_B(\gamma)$
\end{definition}

\begin{lemma}[Messages of buffer]
  The buffer includes messages delivered by Process~A but not delivered by
  Process~B before the receipt of $\alpha$. This excludes messages delivered by
  Process~A before the sending of $\alpha$ and messages delivered by Process~B
  before the receipt of $\alpha$.\\
  $\forall m,\,m',\,(m\neq m'),\,
  s_A(\alpha) \rightarrow d_A(m) \wedge
  d_A(m) \rightarrow s_A(\gamma) \wedge
  d_B(m') \rightarrow r_B(\alpha) \implies m \in B$
\end{lemma}

\begin{proof}
  Since control messages $\alpha$ and $\gamma$ travel by reliable FIFO links,
  the receipt of all messages delivered by Process~A before the sending of
  $\alpha$ precedes the receipt of $\alpha$ by Process~B:\\
  $\forall m,\, d_A(m) \rightarrow s_A(\alpha) \implies d_B(m) \rightarrow
  r_B(m) \implies m \not\in B$\\
  \TODO{Not sure where we are going.}
%%  $ m \not\in B \Longleftrightarrow d_B(m) \rightarrow r_B(\pi_1) \wedge r_B(\pi_2) \rightarrow d_B(m)$
\end{proof}


\begin{figure*}
  \begin{center}
    \input{input/figtimelinerpcbroadcast.tex}
    \caption{\label{fig:timeline}Timeline of \RPCBROADCAST when Process~A adds a
      link to Process~B in its out-view. We hide intermediate processes for the
      purpose of clarity. Messages arrive in causal order.}
  \end{center}
\end{figure*}


\RPCBROADCAST interlaces 3 buffering phases. A control message $\beta$ becomes a
control message $\alpha$ of the next buffering phase. It must travel by safe
links. Figure~\ref{fig:timeline} depicts the functioning of \RPCBROADCAST on a
timeline when Process~A wants to add Process~B in its out-view. 
\begin{enumerate}[leftmargin=*]
\item Process~A starts a first buffering phase. It sends a first control message
  $\alpha$ to Process~B using safe links. 
\item Process~B receives $\alpha$ after all messages $\mathcal{A}$ delivered by
  Process~A before the sending of $\alpha$ plus other concurrent messages
  $\mathcal{B}$.  Process~B starts to register messages it delivers in a buffer
  $B_\alpha$.  Process~B starts a second buffering phase. It sends a second
  control message using safe links to Process~A.
\item Once Process~A receives $\beta$, it received $\mathcal{B}$ plus other
  concurrent messages $\mathcal{C}$. Process~A starts to register messages it
  delivers in a buffer $B$. $B_\alpha$ and $B$ do not contain messages from
  $\mathcal{A}$ and $\mathcal{B}$.
  Then, Process~A starts a third buffering phase. It sends a third control
  message $\pi$ to Process~B using safe link. This corresponds to the ping phase
  of \PCBROADCAST.
\item Once Process~B receives $\pi$, it ends the first buffering phase.
  Process~B stops buffering messages in $B_\alpha$. Process~B delivered and
  buffered all messages in $\mathcal{C}$ plus concurrent messages
  $\mathcal{D}$. $B_\alpha$ contains all concurrent messages between
  $s_B(\beta_{BA})$ and $r_B(\pi_{AB})$. Most importantly, it contains the
  concurrent messages delivered by Process~B between $s_A(\pi_{AB})$ and
  $r_B(\pi_{AB})$. It also contains meaningless messages from $\mathcal{C}$.
  Process~B also starts to register messages it delivers in $B_\pi$.
  Process~B sends a fourth and last control message $\rho$ to Process~B
  using safe links. 
\item Once Process~A receives $\rho$, it ends the second buffering
  phase. Process~A delivered all concurrent messages $\mathcal{D}$ plus other
  concurrent messages $\mathcal{E}$. Process~A sends its buffer of messages $B$
  using the new link $s_{AB}(B)$ and starts using this link normally. The new
  link is safe.
\item Once Process~B receives the buffer, it ends the third buffering
  phase. Using $B$, $B_\alpha$, and $B_\pi$, Process~B is able to identify
  messages expected from Process~A and new messages from Process~A.

\begin{definition}[To expect]
  When Process~B receives the buffer from Process~A, the link becomes safe.
  Process~B expects from Process~A messages delivered by Process~B but not
  delivered by Process~A at the moment of the sending.
  $\forall m,\, d_B(m) \rightarrow r_B(B)  \wedge d_A(m) \not\rightarrow r_A(\rho_{AB}) \implies r_{BA}(m)$
\end{definition}

The set of expected messages is $B_\pi \setminus (B \setminus B_\alpha)$.  It
registers these messages to discard them when they arrive.

\begin{definition}[To deliver]
  When Process~B receives the buffer from Process~A, it delivers messages it did
  not deliver that are delivered by Process~A at the moment of the sending.
  $\forall m \in B,\, d_B(m) \not\rightarrow r_{BA}(B) \implies r_{BA}(B) \rightarrow
  d_B(m)$
\end{definition}

The set of messages to deliver is $B\setminus B_\alpha \setminus B_\pi$. It
delivers them in causal order.
\end{enumerate}

% Process~A maintains 1 buffer to ensure causal order that starts upon receipt of
% $\beta$ and stops upon receipt of $\rho$; and Process~B maintains 2 buffers to
% identify messages to deliver and to expect from Process~A.


Similarly to \PCBROADCAST, the size of buffers may increase unbounded when
intermediate processes are faulty. Control messages never reach their
destination. \PCBROADCAST handles such crashes using a timeout and retry
policy. Such strategy fits \RPCBROADCAST.


\subsection{Complexity}
\label{subsec:complexity}

In this section, we analyze the complexity of \RPCBROADCAST in terms of
broadcast message overhead, delivery execution time, local space consumption,
and number of control messages. 

\noindent The \textbf{broadcast message overhead} is constant $O(1)$, for it
only piggyback the control information to ensure reliable FIFO links.

\noindent The \textbf{delivery execution time}, i.e., the time complexity of the
receipt function, is constant $O(1)$, for it only checks if the message should
be discarded or delivered.

\noindent The \textbf{local space consumption} depends on the size of
buffers. There are 4 buffers in total. $W$ is the size of buffers related to
reliable FIFO links. A link may delay the delivery of messages to await some
preceding messages. $B$ is the size of buffers of messages that increases when
the process adds a neighbor in its out-view, and decreases when a link become
safe. $B_\alpha$ and $B_\pi$ are the size of buffers of messages that increases
when the process gets added as neighbor, and decreases when a links in its
in-view become safe. The space complexity of \RPCBROADCAST is
$O(W + B + B_\alpha + B_\pi)$. It grows and shrinks depending on the dynamicity
of the system. If the system becomes static, the space complexity of
\RPCBROADCAST is $O(W)$. If the system becomes quiescent, the space complexity
of \RPCBROADCAST is $O(B + B_\alpha + B_\pi)$.  If the system becomes both
static and quiescent, \RPCBROADCAST does not consume
space. 

\noindent The overhead in terms of \textbf{number of control messages} per added
link in an out-view varies from $6$ to $4N^2$ depending on the overlay
network. It achieves $6$ messages when Process~A adds Process~B using Process~C
as mediator, and Process~B has Process~A in its out-view. It achieves $4N^2$
when Process~A adds Process~B without knowledge of any route. Process~A and
Process~B fall back to reliable broadcast to disseminate control
messages. \TODO{$N$ is the size of the network.}

Overall, this analysis shows that \RPCBROADCAST proposes an advantageous
tradeoff when the overlay network allows routing between the process that adds
the neighbor and the latter. Fortunately, a wide range of peer-sampling
protocols building overlay networks rely on close neighbor-to-neighbor
interactions to establish links (\REF). An \RPCBROADCAST built on top of these
peer-sampling protocols achieves $8$ control messages per added link. Several
other peer-sampling protocols build addressable overlay networks which allows
routing with a logarithmic number of hops compared to the actual network size
(\REF). An \RPCBROADCAST built on top of these peer-sampling protocols achieves
$O(4\log(N))$ control messages per added link.

Assuming such overlay network, \RPCBROADCAST constitutes a lightweight and
efficient middleware for reliable broadcast and causal broadcast in large and
dynamic distributed systems. As consequence, these broadcast can run in large
and dynamic systems even on most humble devices such as Raspberry Pi's.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
