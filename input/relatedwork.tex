
\section{Related work}
\label{sec:relatedwork}

\begin{table*}
  \begin{center}
    \caption{\label{table:complexity} Complexity of broadcast algorithms at each
      process. $N$ the number of processes that ever broadcast a message. $P$
      the number of processes in the system. $W$ the number of messages received
      but not delivered yet. $Q_i$ is the number of incoming links. $M$ is the
      number of messages already delivered that will be received again from at
      least one link in $Q_i$.}
  \input{input/tablecomplexity.tex}
  \end{center}
\end{table*}

Causal broadcast ensures causal order and properties similar to those of uniform
reliable broadcast~\cite{hadzilacos1994modular}. \RPCBROADCAST uses causal order
to improve on complexity in regards to those properties. 
% Causal broadcast protocols rely on reliable
% broadcast~. Uniform reliable broadcast must ensure
% that
% \begin{inparaenum}[(i)]
% \item all processes receive broadcast messages and
% \item each process delivers each broadcast message once despite multiple
%   receipts.
% \end{inparaenum} 
This section reviews state-of-the-art implementations that forbid multiple
delivery in asynchronous and dynamic systems. 
% This extends from probabilistic
% dissemination approaches to deterministic ones; from physical clock techniques
% to vector-based approaches.

In large and dynamic systems comprising from hundreds to millions of processes,
gossiping constitutes the mean to disseminate
messages. \textbf{Non-deterministic} gossip-based
approaches~\cite{birman1999bimodal,demers1987epidemic} guarantee that each
process receives each broadcast message with high probability. Processes must be
able to identify and retrieve missing messages by themselves. In this paper, we
rely on \textbf{deterministic} gossip-based
approaches~\cite{friedman2004causal,nedelec2017adaptive} where peer-sampling
protocols build connected graph topology. Using all provided reliable links for
broadcast ensures that each process eventually receives each message. A process
keeps a message as long as one of its neighbor did not receive it. Afterwards,
it safely removes it.

Despite possible multiple receipts, processes must deliver messages at most
once. Approaches based on \textbf{dissemination
  pattern~\cite{bravo2017saturn,raynal2013distributed}} build topologies such as
tree or ring. Each process receives each message once, hence delivers it once,
without saving any control information. However, they stay confined to systems
where failures are uncommon~\cite{krasikova2016hashtable}. \RPCBROADCAST
supports dynamicity without assuming any specific topology. 
% It remains in the
% hand of developers to choose the best peer-sampling protocol for their
% requirement and resources.

When multiple receipts can occur, each process maintains a local structure to
detect and discard copies of broadcast messages. Using \textbf{physical
  clocks~\cite{cachin2011introduction,demers1987epidemic}} allows removing
control information over time. Control information is considered obsolete above
an age threshold. The structure is non-monotonic. However, defining the age
threshold is error prone in asynchronous systems. Set too small and processes
may suffer multiple delivery with cascading effects as in
Figure~\ref{fig:memorylinkfailsD}.  \RPCBROADCAST maintains a non-monotonic
structure but makes sure that it removes all and only obsolete control
information.

Using \textbf{logical clocks}~\cite{malkhi2007concise,mukund2014optimized}
allows to discard all copies of broadcast messages at receipt. However, each
process maintains a vector with one entry per process that ever broadcast a
message.  Processes cannot reclaim entries, for it would require running an
overcostly distributed garbage collection that is equivalent to a distributed
consensus~\cite{abdullahi1998garbage}. As consequence, the vector size increases
linearly and monotonically. Vector-based approaches do not scale in large and
dynamic systems where any process can broadcast a message at any
time~\cite{nedelec2016crate}. \RPCBROADCAST's core uses logical clocks
too. Instead of encoding the global state of the system in a vector, it only
maintains its receipt state with its direct out-view. Out-views being far
smaller than the set of all processes in the system,
\RPCBROADCAST scales in large and dynamic systems. \\
However, vector of logical clocks allow each process to perform anti-entropy
with any other process at any time. The former identifies its missing messages
compared to the latter.  The latter sends them to keep consistent states. This
is useful when applications can go
offline~\cite{demers1987epidemic}. \RPCBROADCAST implicitly performs
anti-entropy on-demand to initialize memory link but cannot provide it as a
feature for applications. If required, this is the responsibility of
applications to allow anti-entropy (e.g. using Merkle
tree~\cite{merkle1988digital}).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
