 
\section{Introduction}

%\IEEEPARstart{C}{ausal}

Causal broadcast constitutes the core communication primitive of many
distributed systems~\cite{hadzilacos1994modular}. Applications such as
distributed social networks~\cite{borthakur2013petabyte}, distributed
collaborative software~\cite{heinrich2012exploiting,nedelec2016crate}, or
distributed data
stores~\cite{bailis2013bolton,bravo2017saturn,demers1987epidemic,lloyd2011cops,shapiro2011comprehensive}
use causal broadcast to ensure consistency criteria.  Causal broadcast ensures
reliable receipt of broadcast messages, exactly-once delivery, and causal
delivery following Lamport's happen before
relationship~\cite{lamport1978time}. When Alice comments on Bob's picture,
nobody sees Alice's comment without Bob's picture, and nobody sees multiple
occurrences of Alice's comment or Bob's picture.

PR-Broadcast~\cite{SRDS} is the best implementation of causal
broadcast in large scale and dynamic system. However, PR-Broadcast is
unable to forget any of its information control.  

% Large and dynamic systems can comprise from hundreds to millions of processes
% joining, leaving, and self-reconfiguring at any time. Gossiping enables
% efficient propagation of broadcast messages to all processes of such systems:
% processes broadcast and forward messages to a subset of processes --~their
% neighbors~-- which can be significantly smaller than the number of processes in
% the system. The forwarding implies that processes may receive multiple copies a
% broadcast message from different neighbors.

% To forbid multiple delivery despite multiple receipts, processes must remember
% delivered messages as long as they may receive them again. Afterwards, processes
% can safely forget about these messages.

% % Causal broadcast forbids multiple delivery of a broadcast message despite its
% % possible multiple receipts. Keeping all delivered messages to discard
% % additional copies at receipt is overly space consuming. Instead, processes
% % must remember their delivered messages as long as they might receive them
% % again.  Afterwards, processes can safely forget about them.  How to forget
% % delivered messages in asynchronous, large, and dynamic systems?
% % Building a specific dissemination topology such as a tree or a ring ensures
% % single receipt hence single
% % delivery~\cite{bravo2017saturn,raynal2013distributed}. Processes forget about
% % broadcast messages as soon as they receive them. However, such topologies are
% % difficult to maintain in dynamic systems subject to
% % failures~\cite{krasikova2016hashtable}.  


% Using local structures based on logical
% clocks~\cite{malkhi2007concise,mukund2014optimized} allows to build a summary of
% delivered messages. Processes remember the last delivered message coming from
% every other process in the system.  These structures suffer from linearly and
% monotonically increasing size with the number of processes that ever broadcast a
% message.  These approaches eventually become inefficient, for processes cannot
% safely reclaim consumed space without running an overcostly distributed garbage
% collecting protocol~\cite{abdullahi1998garbage}. 


% However, causal broadcast implementations do not scale in large and dynamic
% systems comprising from hundreds to millions of processes joining, leaving, and
% self-reconfiguring at any time. While ensuring causal delivery can be
% lightweight~\cite{nedelec2018pcbroadcast}, forbidding multiple delivery is
% either restrictive in terms of system topology, or overly space consuming.
% Every process delivers every message exactly-once by either
% \begin{inparaenum}[(i)]
% \item building a specific dissemination topology such as a tree or a ring that
%   ensures single receipt hence single
%   delivery~\cite{bravo2017saturn,raynal2013distributed}. However, such
%   topologies are difficult to maintain in dynamic systems subject to
%   failures~\cite{krasikova2016hashtable};
% \item or they maintain a local structure to identify and discard additional
%   copies of an original message at receipt. In asynchronous systems, these
%   structures use logical clocks~\cite{malkhi2007concise,mukund2014optimized}.
%   However, such structures suffer from linearly and monotonically increasing
%   size with the number of processes that ever broadcast a message.  These
%   approaches eventually become inefficient, for processes cannot safely reclaim
%   consumed space without running an overcostly distributed garbage collecting
%   protocol~\cite{abdullahi1998garbage}. State-of-the-art causal broadcast
%   implementations do not scale in large and dynamic systems.
% \end{inparaenum}

% In this paper, we introduce an implementation of causal broadcast that belongs
% to approaches forbidding multiple delivery by using local structures and
% logical clocks.


In this paper, we propose PRC-Broadcast; a causal broadcast that is
able to forget all its information control. In PRC-Broadcast, a
process receives a message on all its incoming communication links
$Q_i$. A process delivers the message after the first reception and
forget the message after the last reception. Consequently, the message
exist onliny in the process between the first reception and last
reception. The main advantage of PRC-causal is that when all broadcast
terminates, processes forget all its information control. Compared to
 PRC-broadcast, vector clock cannot forget its control
 information. They have to keep information control that grow monotonocally.

% In this paper, we introduce an implementation of causal broadcast that remember
% about delivered messages of direct neighbors instead of all processes in the
% system.  The former set being far smaller than the latter, our implementation
% offers an advantageous trade-off that makes causal broadcast a lightweight and
% efficient middleware in large and dynamic systems.
% A process belongs to an overlay network and has neighbors to communicate with
% via incoming and outgoing links.  Broadcast efficiently disseminates messages by
% gossiping~\cite{jelasity2007gossip}: the broadcaster sends the message by its
% outgoing links; each process receiving such message forwards it by its own
% outgoing links. Processes receive the message either directly or
%transitively. 
Our contribution is threefold:
\begin{itemize}[leftmargin=*]
\item We define link memory as a mean for each process to forbid multiple
  delivery. 
  Link memory allows each process to identify processes from which it
  will receive a copy of an already delivered message. This allows each process
  to safely remove obsolete control information about broadcast messages that
  will never be received again. Assuming causal order, we prove that each
  process can build such knowledge even in dynamic systems where processes join,
  leave, or self-reconfigure at any time.
\item We analyze the complexity of our implementation.
\item We evaluate our implementation using large scale simulations. The
  experiments highlight the space consumed and the traffic generated by our
  protocol in dynamic systems with varying latency. The results confirm that the
  proposed approach scales with system settings and use.
\end{itemize}
% Every process maintains a local state registering receipts from processes that
% actually send it messages instead of maintaining a global state registering
% receipts from all processes of the system in a vector of logical clocks. The
% former set of processes being far smaller than the set of processes in the
% system, our approach scales in large and dynamic systems. Our implementation
% The proposed implementation offers an advantageous trade-off that makes causal
% broadcast a lightweight and efficient middleware in large and dynamic systems.

The rest of this paper is organized as follows.
% Section~\ref{sec:motivations}
% shows the issue and motivates this work.
Section~\ref{sec:proposal} describes the model, highlights the issue, introduces
the principle solving the issue, provides an implementation solving the issue
along with its complexity analysis. Section~\ref{sec:experimentation} shows the
experiments. Section~\ref{sec:relatedwork} reviews related work. We conclude in
Section~\ref{sec:conclusion}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
