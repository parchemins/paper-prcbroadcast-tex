
\section{Conclusion}
\label{sec:conclusion}


In this paper, we proposed a causal broadcast implementation that provides a
novel trade-off between speed, memory, and traffic.  Our approach exploits
causal order to improve on the space complexity of the implementation that
forbids multiple delivery. The space complexity depends on system settings and
use. The overhead in terms of number of control messages depends on the
dynamicity of the system and remains low upon the assumption that the overlay
network allows a form of routing.
% Processes pay at the height of
% their usage.
% This approach only uses buffers of messages that grow and shrink when
% processes add new neighbors. They eventually become empty when the system
% becomes static. To achieve this, our approach only uses small control messages
% of constant size. The number of control messages depends on the overlay
% network. Using routing strategies, this number remains small, hence generated
% traffic overhead remains small.
This advantageous trade-off makes causal broadcast a lightweight and efficient
middleware for group communication in distributed systems. This advantageous
trade-off even makes \RPCBROADCAST a lightweight and efficient implementation of
reliable broadcast. %As consequence, causal broadcast and reliable broadcast can
%run in large and dynamic systems even on most humble devices such as Raspberry
%Piâ€™s.

As future work, we plan to investigate on ways to retrieve the partial order of
messages out of \RPCBROADCAST. %Using \RPCBROADCAST, each process experiences a
%flatten version of the partial order. 
Applications may require more than causal order, they also may need to identify
concurrent messages~\cite{sun2009contextbased}. \RPCBROADCAST discards a lot of
information by ignoring multiple receipts altogether. Analyzing the receipt
order could provide insight on the partial order. The cost could depend on the
actual concurrency of the system.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
