
\section{Proposal}
\label{sec:proposal}

In this section, we present \RPCBROADCAST, a causal broadcast protocol removing
the last linear upper bound in terms of number of processes that ever broadcast
a message that remained on space complexity. \RPCBROADCAST exploits the
improvement brought by \PCBROADCAST on generated traffic to reduce the space
consumed by reliable broadcast, at marginal cost.

\subsection{Model}

A distributed system comprises a set of processes that can communicate with each
other using messages. Processes may not have full knowledge of the membership of
the system. Instead, processes build and maintain overlay networks: each process
updates a local partial view of logical communication channels, i.e., a set of
processes to communicate with. The partial view is usually much smaller than the
actual system size. We speak of overlay networks, networks, or distributed
systems indifferently.

\begin{definition}[Overlay network]
  An overlay network comprises a set of processes that run a set of instructions
  sequentially.  An overlay network also comprises a set of directed
  links. \\
  An overlay network is dynamic if the set of processes or the set of links is
  mutable. Otherwise, the overlay network is static. \\
  The set of links departing from a process is its neighborhood, or partial
  view, or out-view. The set of links arriving to a process is its in-view. \\
  A link from a process to another process allows the former to transmit
  information to the latter. Processes transmit information using asynchronous
  message passing.\\
  Processes are faulty if they crash, otherwise they are correct. There are no
  byzantine processes.
\end{definition}

Processes can communicate with each other using message passing. Process~A can
send a message $m$ to Process~B $s_{AB}(m)$. Process~A can receive a message $m$
from another process B $r_{AB}(m)$, or from any other process
$r_A(m)$. Process~A can send a message $m$ to all other processes of the system,
i.e., it broadcasts a message $b_A(m)$. Process~A can deliver a message
$d_A(m)$.

To characterize the order among events such as send, or receive, we define time
in a logical sense using Lamportâ€™s definition.

\begin{definition}[Happen before~\cite{lamport1978time}]
  Happen before is a transitive, irreflexive, and antisymmetric relation that
  defines a strict partial orders of events. The sending of a message always
  precedes its receipt $s_{AB}(m) \rightarrow r_{BA}(m)$. Two messages are
  concurrent if none happens before the other.
\end{definition}

\begin{definition}[Uniform reliable broadcast] 
  When a process broadcasts a message to all processes of the network, correct
  processes eventually receive it. Uniform reliable broadcast guarantees 3
  properties:
  \begin{itemize}[leftmargin=*]
  \item Validity: If a correct process broadcasts a message, then it
    eventually delivers it.
  \item Uniform Agreement: If a process -- correct or not -- delivers a message,
    then all correct processes eventually deliver it.
  \item Uniform Integrity: A process delivers a message at most once, and only if
    it was previously broadcast.
  \end{itemize}
\end{definition}

From uniform integrity, we derive that despite multiple receipts, a process
delivers a message once.

\begin{definition}[Exactly once delivery]
  Each process receives each broadcast message at least once. A process may receive
  a message multiple times but delivers it at most once:
  \begin{enumerate}
  \item $\forall A,\,B,\, b_A(m) \implies r_B(m)$
  \item $\forall m,\, d_A(m) \implies \exists r_A(m),\, r_A(m) \rightarrow d_A(m)$
  \item \label{enum:uniqueness}
    $\forall m,\,m',\, d_A(m) \rightarrow d_A(m') \implies m \neq m'$
  \end{enumerate}
\end{definition}

Property~\ref{enum:uniqueness} suggests the use of a data structure ensuring
uniqueness of messages such as sets or vectors. The data structure allows
processes to remember about prior delivery of messages in order to discard
double receipts.

\begin{definition}[Remembering]
  A process starts to remember a message at its delivery:
  $remember_A(m) \equiv d_A(m)$.  A process delivers only messages not yet
  remembered: \\ $\not\exists m,\, remember_A(m) \rightarrow d_A(m)$.
\end{definition}

\begin{theorem}[\label{theo:rememberinganduniqueness}Remembering ensures
  delivery uniqueness]
  A process delivering only messages it does not remember delivers each received
  message exactly once.
\end{theorem}

\begin{proof}
  A process receiving a message either delivered this message or not. In the
  former case, it already remembers the message, hence discards it. In the
  latter case, it delivers the message for the first time and starts to remember
  it. Subsequent receipts fall in the former case. Consequently, a process
  delivers each message once and only once.
\end{proof}

\TODO{Vector clocks implement remembering but fail to remove obsolete
  information. To be lightweight, we must provide a safe bound on remembering.}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast ensuring uniqueness of delivery in static systems. It
features a data structure that remembers messages for a finite period of time.
This structure is eventually and safely purged over time of delivered messages.
The idea consists in discarding obsolete messages, i.e., messages that will
never be received any longer.

\begin{theorem}[Bound on remembering]
  Assuming processes receive each message a finite number of times, remembering
  a message from its delivery to its last receipt is necessary and sufficient to
  ensure delivery uniqueness.
\end{theorem}

\begin{proof}
  Assuming a finite series of $k$ receipts of a message $m$ at Process~A:
  $r^1_A(m) \rightarrow r^2_A(m) \wedge r^2_A(m) \rightarrow r^3_A(m) \wedge
  \ldots \wedge r^{k-1}_A(m) \rightarrow r^k_A(m)$. \\
  We must show that if Process~A remembers $m$ from its delivery until its
  $k^{th}$ receipt, then Process~A delivers $m$ once. The proof is similar to
  that of Theorem~\ref{theo:rememberinganduniqueness}. After the $k^{th}$
  receipt, Process~A never receives -- hence delivers -- $m$ again. Remembering
  $m$ until the $k^{th}$ receipt is sufficient.\\
  We also must show that if Process~A does not strictly remember $m$ from its
  delivery to its $k^{th}$ receipt, then Process~A delivers $m$ multiple
  times. Process~A delivers and remembers $m$ after its first receipt. Let
  $1\leq j<k$. Process~A stops remembering $m$ after the $j^{th}$ receipt. When
  Process~A receives $m$ for the $(j+1)^{th}$ time, it considers it as a new
  message and delivers it again. This issue may repeat multiple times leading to
  that many deliveries of $m$.
\end{proof}

Algorithm~\ref{algo:reliablebroadcast} keeps track of expected messages until
remembering these messages becomes obsolete. % Similarly to
%Algorithm~\ref{algo:counterrbroadcast},
It uses the in-view and exploits the property that each process sends each
message exactly once to each neighbor in their out-view.  Instead of using
counters as in Figure~\ref{fig:counterproblem}, it associates with each link
from the in-view a set of expected messages.

\begin{definition}[Per link remembering]
  A process remembers a message from its delivery to its last receipt, i.e.,
  once the process received the message from its whole in-view.
  $remember_B(m) \equiv \exists A \in Q_i,\, r_B(m) \wedge \neg r_{BA}(m)$
\end{definition}

\begin{lemma}[Per link remembering ensures delivery uniqueness]
  Assuming a static network where processes cannot join, nor leave, nor
  self-reconfigure their partial views, per link remembering ensures uniqueness
  of delivery.
\end{lemma}

\begin{proof}
  When a process receives a message $m$ for the first time, it expects to
  receive one copy of $m$ for each other neighbor in its in-view. Assuming $k$
  neighbors in its in-view, the process remembers $m$ until it receives $k$
  copies in total. Assuming that each process delivers -- hence forwards -- each
  message exactly once, the former process does not receive more than $k$ copies
  of $m$. Consequently, each process deliver each message exactly once despite
  receiving multiple copies.
\end{proof}

%Algorithms~\ref{algo:counterrbroadcast} and
Algorithm~\ref{algo:reliablebroadcast} guarantees exactly once delivery of
messages in static systems. The local data structure is safely purged over
receipts. However, as soon as the system becomes dynamic, this property may be
violated (see Figure~\ref{fig:counterproblem}). In this paper, we exploit
message ordering to solve this issue.

In addition to reliable delivery, broadcast protocols can guarantee a delivery
order of messages. We focus on causal order. Process~A should deliver a message
$m$ from Process~B after having delivered all messages delivered by Process~B
before the sending of $m$. This order will prove useful to ensure the receipt of
set of messages. %\TODO{Explain that ordering messages will be usefull for us?}

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts.
  $d_A(m) \rightarrow b_A(m') \implies d_B(m) \rightarrow d_B(m')$
\end{definition}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

\begin{figure}
  \begin{center}
    \input{input/figtimelinepcbroadcast.tex}
    \caption{\label{fig:timelinepcbroadcast}Process~A ensures the safety of a
      link to Process~B. $\pi$ travels using safe links through intermediary
      processes that are hidden for the sake of clarity. $\rho$ reaches
      Process~A by any communication mean. Process~A sends the array of buffered
      messages via the new link. The link becomes safe.}
  \end{center}
\end{figure}

\PCBROADCAST (\REF) is a causal broadcast that uses FIFO links, gossiping,
control messages, and buffers to ensure causal order in dynamic systems. A
process broadcasting a message sends the message to an out-view of safe links
that cannot lead to causal order violations.

\begin{definition}[\label{def:safe}Safe link (\REF)]  
  A link from Process~A to Process~B is safe if and only if Process~B received
  or will receive all messages delivered by Process~A before receiving any
  message that Process~A will
  deliver. $safe(AB) \equiv \forall m,\, m',\, d_A(m) \rightarrow s_{AB}(m')
  \implies r_B(m) \rightarrow r_{BA}(m')$
\end{definition}

Links start unsafe, for messages traveling by the new links may arrive before
preceding messages that took longer paths. \PCBROADCAST ensures safety by
sending control messages. Section~\ref{sec:motivations} and
Figure~\ref{fig:timelinepcbroadcast} show its functioning. Process~A sends a
control message $\pi$ to Process~B using safe links and awaits its answer
$\rho$. This is a ping phase.

\begin{definition}[Ping phase (\REF)]
  Ping phase starts when Process~A pings Process~B. Ping messages $\pi$ travel
  using safe links. When Process~B receives this ping, it replies to
  Process~A. Replies $\rho$ travel using any communication mean. Ping phase ends
  when Process~A receives the reply of Process~B.
\end{definition}

\begin{lemma}[\label{lemma:ping}Ping phases acknowledge broadcast receipts (\REF)]
  A ping phase from Process~A to Process~B acknowledges the receipt by B of all
  messages delivered by Process~A before this ping phase.
  $\forall m,\, d_A(m) \rightarrow s_A(\pi_{AB}) \wedge r_A(\rho_{AB}) \implies
  r_B(m)$
\end{lemma}

\PCBROADCAST ensures that all preceding messages arrive before new messages by
acknowledging the receipt of most messages while buffering messages concurrent
to the acknowledgment. Processes receive all messages at least once and
following causal order.

However, \PCBROADCAST does not ensure exactly once delivery by itself. It relies
on a reliable broadcast protocol that either grows linearly compared to the
number of processes that ever broadcast a message (see
Figure~\ref{fig:spaceproblem}), or bounds the remembering of messages but fails
to handle dynamic systems (see Figure~\ref{fig:counterproblem}).

% Process~B adds Process~C in its out-view but Process~C forgot about 
% message $a$ when Process~B received it. This leads to double delivery of $a$
% and subsequent inconsistencies.

% In this paper, we exploit causal communication to implement a stronger meaning
% of safe link at marginal cost. A link becomes safe when it cannot violate both
% causal delivery and exactly once delivery.  This is more expensive to ensure in
% terms of control messages, for it must account for concurrent messages between
% involved processes. The rest of this section describes the operation of our
% proposal and its complexity.



\subsection{Problem statement}
\label{subsec:problemstatement}

To remove the last linear upper bound that remains on space complexity, causal
broadcast must provide a bound on remembering while handle dynamic systems where
processes can join, leave, or self-reconfigure their partial view.

To provide a bound on remembering, upon receipt of a broadcast message, a
process must
\begin{inparaenum}[(i)]
\item identify if it already delivered this message, and
\item identify all other processes that will send it this message.
\end{inparaenum}
In Figure~\ref{fig:counterproblem}, the related issue comes from Process~C being
unable to remember messages it will receive from Process~B's buffer (i.e., the
message $a$) while forgetting about messages it will never receive from
Process~B (i.e., the message $b$).

\begin{problem*}
Assuming Process~A sends a buffer of messages to Process~B in order to finalize
the safety of this link (see Figure~\ref{fig:timelinepcbroadcast}). Upon receipt
of this buffer by Process~B, the scientific problem consists in:
\begin{itemize}[leftmargin=*]
\item Identifying the array of messages from the buffer that are delivered by
  Process~A but not delivered by Process~B;
\item Identifying the set of message messages from the buffer that are delivered
  by Process~A and Process~B;
\item Identifying the set of messages delivered by Process~B that Process~B will
  receive by this safe link.
\end{itemize}
These are the array of messages to deliver, the set of messages to ignore, and
the set of messages to expect, respectively.
\end{problem*}

\begin{figure}
  \begin{center}
    \input{input/figproblemstatement.tex}
    \caption{\label{fig:problemstatement}For each message in the buffer,
      Process~B must identify its category and assign awaited messages on the
      new safe link.}
  \end{center}
\end{figure}

Figure~\ref{fig:problemstatement} depicts the scientific problem. The buffer of
messages sent by Process~A includes messages that are delivered by Process~A
only. Process~B must deliver these messages normally. The buffer of messages
also includes messages already delivered by Process~B. Process~B must remember
these messages to discard them when the buffer arrives. Finally, Process~B
delivered messages that Process~A did not deliver. Since each process delivers
and forwards each message exactly once, Process~B will receive these messages by
this new safe link. Process~B must remember these messages to discard them at
their receipt.

The rest of this section describes a broadcast protocol that solves this problem
and provides its complexity analysis.


\subsection{Operation}

\begin{algorithm}[h]
  \input{./input/algorpcbroadcast.tex}
  \caption{\label{algo:rpcbroadcast}\RPCBROADCAST at Process $p$.}
\end{algorithm}


Algorithm~\ref{algo:rpcbroadcast} shows the instructions of the proposed causal
broadcast. It relies on an implementation of reliable broadcast shown in
Algorithm~\ref{algo:reliablebroadcast}. When the process does not add links to
other processes, nor other processes add links to this process, causal broadcast
operation is that of reliable broadcast. 

In dynamic systems where processes can join, leave, or reconfigure their
out-view at any time, \RPCBROADCAST ensures that links cannot violate causal
broadcast properties. It extends Definition~\ref{def:safe} of safe links by
adding a clause to ensure exactly once delivery.

% When the process wants to add a link to another process for causal broadcast, it
% makes sure that this link cannot break the guaranty that the other process
% delivers each message exactly once in causal order. It extends the meaning of
% safe links stated by Definition~\ref{def:safe}.

\begin{definition}[\label{def:extension}Safe link extension]
  % In addition to Definition~\ref{def:safe}, a link from Process~A to Process~B
  % is safe if it guarantees to Process~A that messages received by Process~B via
  % this link are delivered exactly once.
  A link from Process~A to Process~B is safe if Process~B differentiates among
  its delivered messages the messages it will eventually receive via this new
  link from the messages it will never receive via this new link.
\end{definition}

% Definition~\ref{def:extension} implies that Process~B manages to distinguish
% messages it delivered that are not delivered by Process~A from messages it did
% not delivered that are just delivered by Process~A. The former constitutes
% messages Process~B expects to receive from the link while the latter constitutes
% messages Process~B receives for the first time and should
% deliver. Algorithm~\ref{algo:reliablebroadcast} maintains this knowledge over
% receipts. However, it may fail when processes add neighbors in their out-view
% (see Figure~\ref{fig:generalproblem}).

\RPCBROADCAST solves this problem by delaying the use of links for broadcast
until they become safe. It builds temporary buffers in order to remember
messages as long as they might be received again, taking into account the
dynamicity of the system. Using these buffers, a process is able to retrieve the
knowledge about old messages to ignore, messages to expect, and new messages to
deliver.

\begin{definition}[Buffering phase]
  Process~B starts and stops buffering upon receipt of control messages from
  Process~A. Control messages are $\alpha$, $\beta$, and $\gamma$. Process~A
  sends $\alpha$ to Process~B using safe links. Process~B starts buffering on
  receipt of $\alpha$. Process~B sends $\beta$ to Process~A using any
  communication means. Process~A sends $\gamma$ to Process~B using safe
  links. Process~B stops buffering on receipt of $\gamma$.
  The buffer $Buf$ contains the messages delivered by Process~B. \\
  $m \in Buf \Longleftrightarrow 
  (r_B(\alpha) \rightarrow d_B(m)) \wedge (d_B(m) \rightarrow r_B(\gamma))$
\end{definition}

\begin{lemma}[Messages of buffer]
  The buffer $Buf$ includes messages delivered by Process~A but not delivered by
  Process~B before the receipt of $\alpha$. This excludes messages delivered by
  Process~A before the sending of $\alpha$ and messages delivered by Process~B
  before the receipt of $\alpha$.\\
  $\forall m,\,m',\,(m\neq m'),\,
  s_A(\alpha) \rightarrow d_A(m) \wedge
  d_A(m) \rightarrow s_A(\gamma) \wedge
  d_B(m') \rightarrow r_B(\alpha) \implies m \in Buf$
\end{lemma}

\begin{proof}
  Since control messages $\alpha$ and $\gamma$ travel by reliable FIFO links,
  the receipt of all messages delivered by Process~A before the sending of
  $\alpha$ precedes the receipt of $\alpha$ by Process~B:\\
  $\forall m,\, d_A(m) \rightarrow s_A(\alpha) \implies d_B(m) \rightarrow
  r_B(m) \implies m \not\in Buf$\\
  \TODO{Not sure where we are going.}
\end{proof}

% \begin{figure*}
%   \begin{center}
%     \input{input/figtimelinerpcbroadcast.tex}
%     \caption{\label{fig:timeline}Timeline of \RPCBROADCAST when Process~A adds a
%       link to Process~B in its out-view. We hide intermediate processes for the
%       purpose of clarity. Messages arrive in causal order.}
%   \end{center}
% \end{figure*}

\begin{figure}
  \begin{center}
    \input{input/figtimelineproof.tex}
    \caption{\label{fig:timelineproof}\label{fig:timeline}Timeline of
      \RPCBROADCAST when Process~A adds a link to Process~B in its out-view. We
      hide intermediate processes for the purpose of clarity. Control messages
      $\alpha$, $\beta$, $\pi$, and $\rho$ travel by safe links. Process~A sends
      $B_\beta$ using the new link. Messages arrive in causal order.
      $B_\beta \wedge (B_\alpha \cup B_\pi) = \mathcal{G} \cup \mathcal{C}'$ is
      the set of messages to ignore,
      $B_\beta \setminus B_\alpha \setminus B_\pi = \mathcal{D}'\setminus
      \mathcal{G}$
      is the set of messages to deliver,
      $B_\pi \setminus (B_\beta \setminus B_\alpha) = \mathcal{H}$ is the set of
      messages to expect.}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveA.tex}%
      \caption{\label{fig:solveA}Process~B adds a link to
        Process~C. \RPCBROADCAST ensures its safety. Process~B sends a first
        control message $\alpha$ to Process~C using Process~A as mediator.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveB.tex}%
      \caption{\label{fig:solveB}Process~A receives $\alpha$ and routes it to
        Process~C.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.31\textwidth}
      \centering\input{input/figsolveC.tex}%
      \caption{\label{fig:solveC}Process~C receives $\alpha$ and answers by
        sending $\beta$ to Process~B using Process~A as mediator. Then,
        Process~C broadcasts $c_1$ and registers it in $B_\alpha$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveD.tex}%
      \caption{\label{fig:solveD}Process~A receives $\beta$ and routes it to
        Process~B.  Process~A receives $c_1$ and forwards it to both its
        neighbors.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveE.tex}%
      \caption{\label{fig:solveE}Process~C receives and discards $c_1$.
        Process~B receives $c_1$ and forwards it to its neighbor.  Process~B
        receives $\beta$ and replies $\pi$ to Process~C using Process~A as
        mediator. Process~B broadcasts $b_1$ and registers it in $B_\beta$.}
    \end{subfigure}    
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveF.tex}%
      \caption{\label{fig:solveF}Process~A receives $c_1$ and discards it.
        Process~A receives $\pi$ and routes it to Process~C. Process~A receives
        $b_1$ and forwards it to its neighbors. Process~C broadcasts $c_2$ and
        registers it in $B_\alpha$}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveG.tex}%
      \caption{\label{fig:solveG}Process~A receives $c_2$ and forwards it to
        its neighbors.  Process~B broadcasts $b_2$ and registers it in
        $B_\beta$. Process~C receives $\pi$ and replies $\rho$ to Process~B
        using Process~A as mediator. Then it receives and forwards $b_1$. Then
        it broadcasts $c_3$. It registers $b_1$ and $c_3$ in $B_\pi$.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveH.tex}%
      \caption{\label{fig:solveH}Process~A receives and discards $b_1$.
        Process~A receives and routes $\rho$ to Process~B.  Process~A receives
        and forwards $b_2$ then $c_3$. Process~B receives, forwards, and
        registers $c_2$. Then Process~B receives $\rho$ and sends $B_\beta$ to
        Process~C using the new link.}
    \end{subfigure}
    ~
    \begin{subfigure}[t]{0.48\textwidth}
      \centering\input{input/figsolveI.tex}%
      \caption{\label{fig:solveI}Once Process~A sent $B_\beta$, the new link is
        safe.  Process~C receives $B_\beta$. Process~C does not deliver $b_1$
        and $c_2$, for it already delivered them. Process~C delivers $b_2$ and
        expects another copy from Process~A, for it constitutes a new message.
        Process~C expects to eventually receive $c_3$ from Process~B.}
    \end{subfigure}
    \begin{subfigure}[t]{0.99\textwidth}
      \centering\input{input/figsolveJ.tex}%
      \caption{\label{fig:solveJ}Process~C categorizes each message of
        $B_\beta$ using its two own buffers $B_\alpha$ and $B_\pi$.}
    \end{subfigure}
    \caption{\label{fig:solve}Using buffers and control messages, \RPCBROADCAST 
      provides reliable causal broadcast.}
  \end{center}
\end{figure}



\RPCBROADCAST interlaces 3 buffering phases. One control message of a buffering
phase becomes the control message of the next buffering
phase. Figure~\ref{fig:timeline} depicts the functioning of \RPCBROADCAST and
Figure~\ref{fig:solve} shows a scenario involving buffers. \TODO{Uniformize
  timeline with examples: name of processes.} Process~A adds a link to
Process~B. \RPCBROADCAST ensures link safety in few steps:

\begin{enumerate}[leftmargin=*]
\item Process~A starts a first buffering phase. It sends a first control message
  $\alpha$ to Process~B using safe links (see Line~\ref{line:sendalpha} and
  Figure~\ref{fig:solveA}).
\item After being routed to Process~B by intermediary processes (see
  Figure~\ref{fig:solveB}), $\alpha$ reaches Process~B (see
  Figure~\ref{fig:solveC}).  Process~B starts to register messages it delivers
  in a buffer $B_\alpha$.  Process~B starts a second buffering phase. It sends a
  second control message $\beta$ to Process~A using safe links (see
  Line~\ref{line:sendbeta}). \emph{In Figure~\ref{fig:solveC}, Process~C
    broadcasts $c_1$ and registers it in $B_\alpha$.}
\item After being routed to Process~A (see Figure~\ref{fig:solveD}), $\beta$
  reaches Process~A. Process~A starts to register messages it delivers in a
  buffer $B_\beta$. Process~A starts a third buffering phase. It sends a third
  control message $\pi$ to Process~B using safe link (see
  Line~\ref{line:sendpi}). \emph{In Figure~\ref{fig:solveE}, Process~B
    broadcasts $b_1$ and registers it in $B_\beta$. In Figure~\ref{fig:solveF},
    Process~C broadcasts $c_2$ and registers it in $B_\alpha$.}
\item After being routed to Process~B by intermediary processes (see
  Figure~\ref{fig:solveF}), $\pi$ reaches Process~B. Process~B ends the first
  buffering phase: Process~B stops buffering messages in $B_\alpha$.  Process~B
  starts to register messages it delivers in $B_\pi$.  Process~B sends a fourth
  and last control message $\rho$ to Process~A using safe links (see
  Line~\ref{line:sendrho}). \emph{In Figure~\ref{fig:solveG} Process~C delivers
    $b_1$, broadcasts $c_3$, and registers them in $B_\pi$. In the meantime,
    Process~B broadcasts $b_2$ and registers it in $B_\beta$.}
\item After being routed to Process~A, $\rho$ reaches Process~A (see
  Figure~\ref{fig:solveH}).  Process~A stops buffering and sends its buffer of
  messages $B_\beta$ using the new link $s_{AB}(B)$ (see
  Line~\ref{line:sendbuffer}). \emph{In Figure~\ref{fig:solveI}, this buffer
    contains $b_1$, $b_2$, and $c_2$.} The new link is safe. Process~A starts to
  use this link normally for causal broadcast.
\item Once Process~B receives the buffer, it ends the third buffering phase (see
  Figure~\ref{fig:solveI}). Using $B_\alpha$, and $B_\pi$, Process~B identifies
  among messages from $B_\beta$ the array of messages to deliver (see
  Line~\ref{line:todeliver}). \emph{In Figure~\ref{fig:solveJ}, this array only
    includes $b_2$.}  Using $B_\alpha$, and $B_\pi$, Process~B also identifies
  the set of messages to ignore which is the rest of the buffer. \emph{In
    Figure~\ref{fig:solveJ}, this set includes $b_1$ and $c_2$.} Finally,
  Process~B identifies among its own delivered messages the messages to expect
  from Process~A (see Line~\ref{line:toexpect}). \emph{In
    Figure~\ref{fig:solveJ}, this set includes $c_3$.} Afterwards, messages
  received by this new link are processed normally.
\end{enumerate}
\RPCBROADCAST solves the problem statement of
Section~\ref{subsec:problemstatement}. Consequently, messages from the received
buffer and upcoming messages from the new link do not cause causal order
violations nor exactly once delivery violations.

\begin{proof}
  Figure~\ref{fig:timeline} exposes the different steps of this proof. Assuming
  that Process~A adds Process~B in its out-view. Before sending $\alpha$,
  Process~A delivered a set of messages $\mathcal{A}$. Since $\alpha$ travels
  using causal communication, all messages delivered by Process~A at the moment
  of the sending are delivered by Process~B at the moment of the receipt:
  $\forall m,\, d_A(m) \rightarrow s_A(\alpha_{AB}) \implies d_B(m) \rightarrow
  r_B(\alpha_{AB})$.
  Thus, Process~B delivered a set of messages $\mathcal{B}$ that comprises
  $\mathcal{A}$ and another set of delivered messages $\mathcal{A}'$ unknown to
  Process~A at the moment of the sending. $\mathcal{A}$ and $\mathcal{A}'$ are
  disjoint.\\
  When Process~A receives $\beta$, it delivered $\mathcal{C}$ that comprises
  $\mathcal{B}$ and $\mathcal{B}'$, $\mathcal{B}'$ being a set of messages
  unknown to Process~B at the moment of the sending of $\beta$. \\
  When Process~B receives $\pi$, it delivered $\mathcal{D}$ that comprises
  $\mathcal{C}$ and $\mathcal{C}'$, $\mathcal{C}'$ being the set of messages
  unknown to Process~A at the moment of the sending of $\pi$. Hence, Buffer
  $B_\alpha$ contains the set of messages delivered between the sending of
  $\beta$ and the receipt of $\pi$:
  $\mathcal{D} \setminus \mathcal{C} = \mathcal{A} \cup \mathcal{A}' \cup
  \mathcal{B}' \cup \mathcal{C}' \setminus (\mathcal{A} \cup \mathcal{A'} \cup
  \mathcal{B}' \cup \mathcal{C'} \cup \mathcal{D}') = \mathcal{B}' \cup
  \mathcal{C}'$. \\
  When Process~A receives $\rho$, it delivered $\mathcal{E}$ that comprises
  $\mathcal{D}$ and $\mathcal{D}'$, $\mathcal{D}'$ being a set of messages
  unknown to Process~B at the moment of the sending of $\rho$. Hence, Buffer
  $B_\beta$ contains the array of messages delivered between the receipt of
  $\beta$ and the receipt of $\rho$:
  $\mathcal{E} \setminus \mathcal{C} = \mathcal{C}' \cup \mathcal{D}'$.\\
  When Process~B receives the buffer $B_\beta$, it delivered a set of messages
  that follows the receipt of $\pi$. The buffer $B_\pi$ comprises a set of
  messages $\mathcal{G}$ delivered by Process~A before the sending of $B_\beta$
  and a set of messages $\mathcal{H}$ not delivered by Process~A before the
  sending of $B_\beta$. 
  
  \noindent\textbf{To ignore:} Process~B ignores messages in $\mathcal{C}'$,
  for they are
  delivered by both processes: $B_\beta \setminus B_\alpha = \mathcal{D}'$.
  $\mathcal{G}$ is a subset of the remaining $\mathcal{D}'$ that should be
  ignored: $(B_\beta \setminus B_\alpha) \wedge B_\pi$.

  \noindent \textbf{To deliver:} Process~B delivers messages in $\mathcal{D}'$
  that it did not delivered yet:
  $(B_\beta\setminus B_\alpha) \setminus B_\pi = \mathcal{D}' \setminus
  \mathcal{G}$.
  
  \noindent \textbf{To expect from Process~A:} Process~B expects messages that
  are not in $\mathcal{D}'$:
  $B_\pi \setminus (B_\beta \setminus B_\alpha) = \mathcal{H}$.  Assuming the
  link is not removed, since $\mathcal{H}$ comprises messages delivered by
  Process~B only, and since all processes eventually receive, deliver, and
  forward all messages, Process~B will eventually receive all the expected
  messages $\mathcal{H}$ from this link in causal order.
\end{proof}


Similarly to \PCBROADCAST, the size of buffers may increase unbounded when
intermediate processes are faulty. Control messages never reach their
destination. \PCBROADCAST handles such crashes using a timeout and retry
policy. Such strategy fits \RPCBROADCAST as well. Both involved processes can
halt and retry the safety check of the new link. Either the origin process does
not send its buffer $B_\beta$, or the destination process does not accept
incoming messages.

\subsection{Complexity}
\label{subsec:complexity}

In this section, we analyze the complexity of \RPCBROADCAST in terms of
broadcast message overhead, delivery execution time, local space consumption,
and number of control messages. 

\noindent The \textbf{broadcast message overhead} is constant $O(1)$, for it
only piggyback the control information to ensure reliable FIFO links.

\noindent The \textbf{delivery execution time}, i.e., the time complexity of the
receipt function is $O(Q_i)$, for it only checks in the inview if the message
must be discarded or delivered.

\noindent The \textbf{local space consumption} depends on the size of
buffers. There are 4 buffers in total. $W$ is the size of buffers related to
reliable FIFO links. A link may delay the delivery of messages to await some
preceding messages. $B_\beta$ is the size of buffers of messages that increases when
the process adds a neighbor in its out-view, and decreases when a link become
safe. $B_\alpha$ and $B_\pi$ are the size of buffers of messages that increases
when the process gets added as neighbor, and decreases when a links in its
in-view become safe. The space complexity of \RPCBROADCAST is
$O(W  + B_\alpha + B_\beta + B_\pi)$. It grows and shrinks depending on the dynamicity
of the system. If the system becomes static, the space complexity of
\RPCBROADCAST is $O(W)$. If the system becomes quiescent, the space complexity
of \RPCBROADCAST is $O(B_\alpha+ B_\beta + B_\pi)$.  If the system becomes both
static and quiescent, \RPCBROADCAST does not consume
space. 

\TODO{Not optimal because messages in $\mathcal{B}'$ that will never be received
  by Process~B from Process~A, yet remembered.}


\noindent The overhead in terms of \textbf{number of control messages} per added
link in an out-view varies from $6$ to $4P^2$ depending on the overlay network;
$P$ being the number of processes in the system. It achieves $6$ messages when
Process~A adds Process~B using Process~C as mediator, and Process~B has
Process~A in its out-view. It achieves $4P^2$ when Process~A adds Process~B
without knowledge of any route. Process~A and Process~B fall back to reliable
broadcast to disseminate control messages.

Overall, this analysis shows that \RPCBROADCAST proposes an advantageous
tradeoff when the overlay network allows routing between the process that adds
the neighbor and the latter. Fortunately, a wide range of peer-sampling
protocols building overlay networks rely on close neighbor-to-neighbor
interactions to establish links (\REF). An \RPCBROADCAST built on top of these
peer-sampling protocols achieves $8$ control messages per added link. Several
other peer-sampling protocols build addressable overlay networks which allows
routing with a logarithmic number of hops compared to the actual network size
(\REF). An \RPCBROADCAST built on top of these peer-sampling protocols achieves
$O(4\log(P))$ control messages per added link.

Assuming such overlay network, \RPCBROADCAST constitutes a lightweight and
efficient middleware for reliable broadcast and causal broadcast in large and
dynamic distributed systems. As consequence, these broadcast can run in large
and dynamic systems even on most humble devices such as Raspberry Pi's.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
