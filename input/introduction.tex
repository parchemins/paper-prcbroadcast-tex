 
\section{Introduction}

%\IEEEPARstart{C}{ausal}

Causal broadcast constitutes the core communication primitive of many
distributed systems~\cite{hadzilacos1994modular}. Applications such as
distributed social networks~\cite{borthakur2013petabyte}, distributed
collaborative software~\cite{heinrich2012exploiting,nedelec2016crate}, or
distributed data
stores~\cite{bailis2013bolton,bravo2017saturn,demers1987epidemic,lloyd2011cops,shapiro2011comprehensive}
use causal broadcast to ensure consistency criteria.  Causal broadcast ensures
reliable receipt of broadcast messages, exactly-once delivery, and causal
delivery following Lamport's happen before
relationship~\cite{lamport1978time}. When Alice comments on Bob's picture,
nobody sees Alice's comment without Bob's picture, and nobody sees multiple
occurrences of Alice's comment or Bob's picture.


Vector clock-based
approaches~\cite{malkhi2007concise,mukund2014optimized,nedelec2018pcbroadcast}
need to keep all their control information forever. They cannot forget any
control information.  The consumed memory monotonically increases with the
number of processes that ever broadcast a message $O(N)$.  They become
unpractical in large and dynamic system comprising from hundreds to millions of
processes joining, leaving, self-reconfiguring, or crashing at any time.


% Large and dynamic systems can comprise from hundreds to millions of processes
% joining, leaving, and self-reconfiguring at any time. Gossiping enables
% efficient propagation of broadcast messages to all processes of such systems:
% processes broadcast and forward messages to a subset of processes --~their
% neighbors~-- which can be significantly smaller than the number of processes in
% the system. The forwarding implies that processes may receive multiple copies a
% broadcast message from different neighbors.

% To forbid multiple delivery despite multiple receipts, processes must remember
% delivered messages as long as they may receive them again. Afterwards, processes
% can safely forget about these messages.

% % Causal broadcast forbids multiple delivery of a broadcast message despite its
% % possible multiple receipts. Keeping all delivered messages to discard
% % additional copies at receipt is overly space consuming. Instead, processes
% % must remember their delivered messages as long as they might receive them
% % again.  Afterwards, processes can safely forget about them.  How to forget
% % delivered messages in asynchronous, large, and dynamic systems?
% % Building a specific dissemination topology such as a tree or a ring ensures
% % single receipt hence single
% % delivery~\cite{bravo2017saturn,raynal2013distributed}. Processes forget about
% % broadcast messages as soon as they receive them. However, such topologies are
% % difficult to maintain in dynamic systems subject to
% % failures~\cite{krasikova2016hashtable}.  


% Using local structures based on logical
% clocks~\cite{malkhi2007concise,mukund2014optimized} allows to build a summary of
% delivered messages. Processes remember the last delivered message coming from
% every other process in the system.  These structures suffer from linearly and
% monotonically increasing size with the number of processes that ever broadcast a
% message.  These approaches eventually become inefficient, for processes cannot
% safely reclaim consumed space without running an overcostly distributed garbage
% collecting protocol~\cite{abdullahi1998garbage}. 


% However, causal broadcast implementations do not scale in large and dynamic
% systems comprising from hundreds to millions of processes joining, leaving, and
% self-reconfiguring at any time. While ensuring causal delivery can be
% lightweight~\cite{nedelec2018pcbroadcast}, forbidding multiple delivery is
% either restrictive in terms of system topology, or overly space consuming.
% Every process delivers every message exactly-once by either
% \begin{inparaenum}[(i)]
% \item building a specific dissemination topology such as a tree or a ring that
%   ensures single receipt hence single
%   delivery~\cite{bravo2017saturn,raynal2013distributed}. However, such
%   topologies are difficult to maintain in dynamic systems subject to
%   failures~\cite{krasikova2016hashtable};
% \item or they maintain a local structure to identify and discard additional
%   copies of an original message at receipt. In asynchronous systems, these
%   structures use logical clocks~\cite{malkhi2007concise,mukund2014optimized}.
%   However, such structures suffer from linearly and monotonically increasing
%   size with the number of processes that ever broadcast a message.  These
%   approaches eventually become inefficient, for processes cannot safely reclaim
%   consumed space without running an overcostly distributed garbage collecting
%   protocol~\cite{abdullahi1998garbage}. State-of-the-art causal broadcast
%   implementations do not scale in large and dynamic systems.
% \end{inparaenum}

% In this paper, we introduce an implementation of causal broadcast that belongs
% to approaches forbidding multiple delivery by using local structures and
% logical clocks.


In this paper, we propose a novel implementation of causal broadcast that
forgets all and only obsolete control information. A process $p$ that has $i$
incoming links receives each message $i$ times. A message $m$ is active for $p$
between its first and last reception by $p$. Process $p$ keeps control
information about all its active messages. As soon as a message becomes
inactive, the process can forget all control information related to it.
Consequently, processes do no store any permanent control information about
messages. When no message is active, no control information is stored in the
system.  Our contribution is threefold:
\begin{itemize}[leftmargin=*]
\item We define the notion of \emph{link memory} as a mean for each process to
  forbid multiple delivery.  Link memory allows each process to identify
  processes from which it will receive a copy of an already delivered
  message. This allows each process to safely remove obsolete control
  information about broadcast messages that will never be received again. We
  prove that using a causal delivery, each process can build such knowledge even
  in dynamic systems where processes may join, leave, self-reconfigure, or crash
  at any time.
\item We propose an implementation of causal broadcast that uses the notion of
  link memory, where each process manages a local data the size of which is
  $O(i \cdot A)$ where $i$ is the number of incoming links and $A$ is the number
  of active messages. Moreover, the only control information piggybacked on
  messages is a scalar Lamport clock.
\item We evaluate our implementation using large scale simulations. The
  experiments highlight the space consumed and the traffic generated by our
  protocol in dynamic systems with varying latency. The results confirm that the
  proposed approach scales with system settings and use.
\end{itemize}
% Every process maintains a local state registering receipts from processes that
% actually send it messages instead of maintaining a global state registering
% receipts from all processes of the system in a vector of logical clocks. The
% former set of processes being far smaller than the set of processes in the
% system, our approach scales in large and dynamic systems. Our implementation
% The proposed implementation offers an advantageous trade-off that makes causal
% broadcast a lightweight and efficient middleware in large and dynamic systems.

The rest of this paper is organized as follows.
% Section~\ref{sec:motivations}
% shows the issue and motivates this work.
Section~\ref{sec:proposal} describes the model, highlights the issue, introduces
the principle solving the issue, provides an implementation solving the issue
along with its complexity analysis. Section~\ref{sec:experimentation} shows the
experiments. Section~\ref{sec:relatedwork} reviews related work. We conclude in
Section~\ref{sec:conclusion}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
